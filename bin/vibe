#!/usr/bin/env node

/**
 * vibe CLI
 * SPEC-driven AI coding framework (Claude Code ì „ìš©)
 */

const path = require('path');
const fs = require('fs');

const args = process.argv.slice(2);
const command = args[0];

// ì˜µì…˜ íŒŒì‹±
const options = {
  silent: args.includes('--silent') || args.includes('-s')
};

// MCP ì„¤ì •
const DEFAULT_MCPS = [
  { name: 'vibe', type: 'node', local: true },
  { name: 'context7', type: 'npx', package: '@upstash/context7-mcp@latest' }
];

const EXTERNAL_LLMS = {
  gpt: {
    name: 'vibe-gpt',
    role: 'architecture',
    description: 'ì•„í‚¤í…ì²˜/ë””ë²„ê¹… (GPT 5.2)',
    package: '@anthropics/openai-mcp',
    envKey: 'OPENAI_API_KEY'
  },
  gemini: {
    name: 'vibe-gemini',
    role: 'ui-ux',
    description: 'UI/UX ì„¤ê³„ (Gemini 3)',
    package: '@anthropics/gemini-mcp',
    envKey: 'GOOGLE_API_KEY'
  }
};

// ë¡œê·¸ í•¨ìˆ˜ (silent ëª¨ë“œ ì§€ì›)
function log(message) {
  if (!options.silent) {
    console.log(message);
  }
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function copyDirContents(sourceDir, targetDir) {
  if (fs.existsSync(sourceDir)) {
    fs.readdirSync(sourceDir).forEach(file => {
      fs.copyFileSync(path.join(sourceDir, file), path.join(targetDir, file));
    });
  }
}

function copyDirRecursive(sourceDir, targetDir) {
  if (!fs.existsSync(sourceDir)) return;

  ensureDir(targetDir);

  fs.readdirSync(sourceDir).forEach(item => {
    const sourcePath = path.join(sourceDir, item);
    const targetPath = path.join(targetDir, item);

    if (fs.statSync(sourcePath).isDirectory()) {
      copyDirRecursive(sourcePath, targetPath);
    } else {
      fs.copyFileSync(sourcePath, targetPath);
    }
  });
}

// í˜‘ì—…ì ìë™ ì„¤ì¹˜ ì„¤ì •
function setupCollaboratorAutoInstall(projectRoot) {
  const packageJsonPath = path.join(projectRoot, 'package.json');
  const vibeDir = path.join(projectRoot, '.vibe');
  const packageJson = require('../package.json');
  const vibeVersion = packageJson.version;

  // 1. Node.js í”„ë¡œì íŠ¸: package.jsonì— devDependency + postinstall ì¶”ê°€
  if (fs.existsSync(packageJsonPath)) {
    try {
      const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));

      let modified = false;

      // devDependenciesì— vibe ì¶”ê°€
      if (!pkg.devDependencies) {
        pkg.devDependencies = {};
      }
      if (!pkg.devDependencies['@su-record/vibe']) {
        pkg.devDependencies['@su-record/vibe'] = `^${vibeVersion}`;
        modified = true;
      }

      // scriptsì— postinstall ì¶”ê°€
      if (!pkg.scripts) {
        pkg.scripts = {};
      }
      if (!pkg.scripts.postinstall) {
        pkg.scripts.postinstall = 'vibe update --silent';
        modified = true;
      } else if (!pkg.scripts.postinstall.includes('vibe update')) {
        // ê¸°ì¡´ postinstallì´ ìˆìœ¼ë©´ vibe update ì¶”ê°€
        pkg.scripts.postinstall = `${pkg.scripts.postinstall} && vibe update --silent`;
        modified = true;
      }

      if (modified) {
        fs.writeFileSync(packageJsonPath, JSON.stringify(pkg, null, 2) + '\n');
        log('   âœ… package.jsonì— í˜‘ì—…ì ìë™ ì„¤ì¹˜ ì„¤ì • ì¶”ê°€\n');
      } else {
        log('   â„¹ï¸  package.json í˜‘ì—… ì„¤ì • ì´ë¯¸ ì¡´ì¬\n');
      }
    } catch (e) {
      log('   âš ï¸  package.json ìˆ˜ì • ì‹¤íŒ¨: ' + e.message + '\n');
    }
  }

  // 2. ë²”ìš©: .vibe/setup.sh ìƒì„± (ë¹„-Node í”„ë¡œì íŠ¸ ë˜ëŠ” ì¶”ê°€ ì§€ì›)
  const setupShPath = path.join(vibeDir, 'setup.sh');
  if (!fs.existsSync(setupShPath)) {
    const setupScript = `#!/bin/bash
# Vibe í˜‘ì—…ì ìë™ ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸
# ì‚¬ìš©ë²•: ./.vibe/setup.sh

set -e

echo "ğŸ”§ Vibe ì„¤ì¹˜ í™•ì¸ ì¤‘..."

# npm/npx í™•ì¸
if ! command -v npx &> /dev/null; then
    echo "âŒ Node.js/npmì´ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤."
    echo "   https://nodejs.org ì—ì„œ ì„¤ì¹˜í•´ì£¼ì„¸ìš”."
    exit 1
fi

# vibe ì„¤ì¹˜ í™•ì¸ ë° ì—…ë°ì´íŠ¸
if command -v vibe &> /dev/null; then
    echo "âœ… Vibeê°€ ì´ë¯¸ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤."
    vibe update --silent
    echo "âœ… Vibe ì—…ë°ì´íŠ¸ ì™„ë£Œ!"
else
    echo "ğŸ“¦ Vibe ì„¤ì¹˜ ì¤‘..."
    npm install -g @su-record/vibe
    vibe update --silent
    echo "âœ… Vibe ì„¤ì¹˜ ë° ì„¤ì • ì™„ë£Œ!"
fi

echo ""
echo "ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì‹œì‘í•˜ì„¸ìš”:"
echo "  /vibe.spec \\"ê¸°ëŠ¥ëª…\\"    SPEC ì‘ì„±"
echo "  /vibe.run \\"ê¸°ëŠ¥ëª…\\"     êµ¬í˜„ ì‹¤í–‰"
`;
    fs.writeFileSync(setupShPath, setupScript);
    fs.chmodSync(setupShPath, '755');
    log('   âœ… í˜‘ì—…ì ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸ ìƒì„± (.vibe/setup.sh)\n');
  }
}

// í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
async function init(projectName) {
  try {
    let projectRoot = process.cwd();
    let isNewProject = false;

    if (projectName) {
      projectRoot = path.join(process.cwd(), projectName);

      if (fs.existsSync(projectRoot)) {
        log(`âŒ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤: ${projectName}/`);
        return;
      }

      log(`ğŸ“ ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±: ${projectName}/\n`);
      fs.mkdirSync(projectRoot, { recursive: true });
      isNewProject = true;
    }

    const vibeDir = path.join(projectRoot, '.vibe');
    if (fs.existsSync(vibeDir)) {
      log('âŒ .vibe/ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.');
      return;
    }

    // MCP ì„œë²„ ë“±ë¡ (Claude Code)
    log('ğŸ”§ Claude Code MCP ì„œë²„ ë“±ë¡ ì¤‘...\n');
    const { execSync } = require('child_process');

    // 1. hi-ai MCP (ê¸°ì¡´)
    const mcpPath = path.join(__dirname, '..', 'node_modules', '@su-record', 'hi-ai', 'dist', 'index.js');
    try {
      execSync(`claude mcp add vibe node "${mcpPath}"`, { stdio: 'pipe' });
      log('   âœ… vibe MCP ë“±ë¡ ì™„ë£Œ\n');
    } catch (e) {
      if (e.message.includes('already exists')) {
        log('   â„¹ï¸  vibe MCP ì´ë¯¸ ë“±ë¡ë¨\n');
      } else {
        log('   âš ï¸  vibe MCP ìˆ˜ë™ ë“±ë¡ í•„ìš”\n');
      }
    }

    // 2. Context7 MCP (ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ ê²€ìƒ‰)
    try {
      execSync('claude mcp add context7 -- npx -y @upstash/context7-mcp@latest', { stdio: 'pipe' });
      log('   âœ… Context7 MCP ë“±ë¡ ì™„ë£Œ (ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ ê²€ìƒ‰)\n');
    } catch (e) {
      if (e.message.includes('already exists')) {
        log('   â„¹ï¸  Context7 MCP ì´ë¯¸ ë“±ë¡ë¨\n');
      } else {
        log('   âš ï¸  Context7 MCP ìˆ˜ë™ ë“±ë¡ í•„ìš”: claude mcp add context7 -- npx -y @upstash/context7-mcp@latest\n');
      }
    }

    // 3. Exa MCP (AI ì›¹ ê²€ìƒ‰) - API í‚¤ í•„ìš”
    log('   â„¹ï¸  Exa MCP (AI ì›¹ ê²€ìƒ‰): EXA_API_KEY í™˜ê²½ë³€ìˆ˜ ì„¤ì • í›„ ì•„ë˜ ëª…ë ¹ì–´ë¡œ ë“±ë¡\n');
    log('      claude mcp add exa -e EXA_API_KEY=$EXA_API_KEY -- npx -y exa-mcp-server\n');

    // .vibe í´ë” êµ¬ì¡° ìƒì„±
    const dirs = ['', 'specs', 'features'];
    dirs.forEach(dir => {
      ensureDir(path.join(vibeDir, dir));
    });

    // .claude/commands ë³µì‚¬
    const claudeDir = path.join(projectRoot, '.claude');
    const commandsDir = path.join(claudeDir, 'commands');
    ensureDir(claudeDir);
    ensureDir(commandsDir);

    const sourceDir = path.join(__dirname, '../.claude/commands');
    copyDirContents(sourceDir, commandsDir);
    log('   âœ… ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ì„¤ì¹˜ ì™„ë£Œ (7ê°œ)\n');

    // ì„¤ì • íŒŒì¼ ìƒì„±
    const templatePath = path.join(__dirname, '../templates/constitution-template.md');
    const constitutionPath = path.join(vibeDir, 'constitution.md');
    if (fs.existsSync(templatePath)) {
      fs.copyFileSync(templatePath, constitutionPath);
    }

    const config = {
      language: 'ko',
      quality: { strict: true, autoVerify: true }
    };
    fs.writeFileSync(path.join(vibeDir, 'config.json'), JSON.stringify(config, null, 2));

    // CLAUDE.md ë³‘í•© (ê¸°ì¡´ ë‚´ìš© ë³´ì¡´)
    const vibeClaudeMd = path.join(__dirname, '../CLAUDE.md');
    const projectClaudeMd = path.join(projectRoot, 'CLAUDE.md');

    if (fs.existsSync(projectClaudeMd)) {
      // ê¸°ì¡´ CLAUDE.mdê°€ ìˆìœ¼ë©´ vibe ì„¹ì…˜ ì¶”ê°€
      const existingContent = fs.readFileSync(projectClaudeMd, 'utf-8');
      const vibeContent = fs.readFileSync(vibeClaudeMd, 'utf-8');

      if (!existingContent.includes('/vibe.spec')) {
        // vibe ì„¹ì…˜ì´ ì—†ìœ¼ë©´ ëì— ì¶”ê°€
        const mergedContent = existingContent.trim() + '\n\n---\n\n' + vibeContent;
        fs.writeFileSync(projectClaudeMd, mergedContent);
        log('   âœ… CLAUDE.mdì— vibe ì„¹ì…˜ ì¶”ê°€\n');
      } else {
        log('   â„¹ï¸  CLAUDE.mdì— vibe ì„¹ì…˜ ì´ë¯¸ ì¡´ì¬\n');
      }
    } else {
      // ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
      fs.copyFileSync(vibeClaudeMd, projectClaudeMd);
      log('   âœ… CLAUDE.md ìƒì„±\n');
    }

    // .vibe/rules/ ë³µì‚¬ (ì½”ë”© ê·œì¹™)
    const rulesSource = path.join(__dirname, '../.vibe/rules');
    const rulesTarget = path.join(vibeDir, 'rules');
    copyDirRecursive(rulesSource, rulesTarget);
    log('   âœ… ì½”ë”© ê·œì¹™ ì„¤ì¹˜ ì™„ë£Œ (.vibe/rules/)\n');

    // .claude/agents/ ë³µì‚¬ (ì„œë¸Œì—ì´ì „íŠ¸)
    const agentsDir = path.join(claudeDir, 'agents');
    ensureDir(agentsDir);
    const agentsSourceDir = path.join(__dirname, '../.claude/agents');
    copyDirContents(agentsSourceDir, agentsDir);
    log('   âœ… ì„œë¸Œì—ì´ì „íŠ¸ ì„¤ì¹˜ ì™„ë£Œ (.claude/agents/)\n');

    // .claude/settings.json ìƒì„± (Hooks ì„¤ì • - ì €ì¥ì†Œ ê³µìœ ìš©)
    const settingsPath = path.join(claudeDir, 'settings.json');
    if (!fs.existsSync(settingsPath)) {
      const hooksTemplate = path.join(__dirname, '../templates/hooks-template.json');
      if (fs.existsSync(hooksTemplate)) {
        fs.copyFileSync(hooksTemplate, settingsPath);
        log('   âœ… Hooks ì„¤ì • ì„¤ì¹˜ ì™„ë£Œ (.claude/settings.json)\n');
      }
    } else {
      log('   â„¹ï¸  Hooks ì„¤ì • ì´ë¯¸ ì¡´ì¬\n');
    }

    // .gitignoreì—ì„œ settings.local.json ì œê±° (ì €ì¥ì†Œ ê³µìœ  í•„ìš”)
    const gitignorePath = path.join(projectRoot, '.gitignore');
    if (fs.existsSync(gitignorePath)) {
      let gitignore = fs.readFileSync(gitignorePath, 'utf-8');
      if (gitignore.includes('settings.local.json')) {
        gitignore = gitignore.replace(/\.claude\/settings\.local\.json\n?/g, '');
        gitignore = gitignore.replace(/settings\.local\.json\n?/g, '');
        fs.writeFileSync(gitignorePath, gitignore);
        log('   âœ… .gitignoreì—ì„œ settings.local.json ì œê±° (ì €ì¥ì†Œ ê³µìœ )\n');
      }
    }

    // í˜‘ì—…ì ìë™ ì„¤ì¹˜ ì„¤ì •
    setupCollaboratorAutoInstall(projectRoot);

    // ì™„ë£Œ ë©”ì‹œì§€
    log(`
âœ… vibe ì´ˆê¸°í™” ì™„ë£Œ!

${isNewProject ? `í”„ë¡œì íŠ¸ ìœ„ì¹˜:
  ${projectRoot}/

` : ''}ìƒì„±ëœ êµ¬ì¡°:
  CLAUDE.md                      # í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸
  .claude/
  â”œâ”€â”€ commands/                  # ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (7ê°œ)
  â”œâ”€â”€ agents/                    # ì„œë¸Œì—ì´ì „íŠ¸ (simplifier)
  â””â”€â”€ settings.json              # Hooks ì„¤ì • (ì €ì¥ì†Œ ê³µìœ )
  .vibe/
  â”œâ”€â”€ config.json                # í”„ë¡œì íŠ¸ ì„¤ì •
  â”œâ”€â”€ constitution.md            # í”„ë¡œì íŠ¸ ì›ì¹™
  â”œâ”€â”€ setup.sh                   # í˜‘ì—…ì ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸
  â”œâ”€â”€ rules/                     # ì½”ë”© ê·œì¹™
  â”‚   â”œâ”€â”€ core/                  # í•µì‹¬ ì›ì¹™
  â”‚   â”œâ”€â”€ quality/               # í’ˆì§ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸
  â”‚   â””â”€â”€ languages/             # ì–¸ì–´ë³„ ê·œì¹™
  â”œâ”€â”€ specs/                     # SPEC ë¬¸ì„œë“¤
  â””â”€â”€ features/                  # BDD Feature íŒŒì¼ë“¤

MCP ì„œë²„ (hi-ai): âœ“
í˜‘ì—…ì ìë™ ì„¤ì¹˜: âœ“

ì‚¬ìš©ë²•:
  /vibe.spec "ê¸°ëŠ¥ëª…"            SPEC ì‘ì„± (ëŒ€í™”í˜•)
  /vibe.run "ê¸°ëŠ¥ëª…"             êµ¬í˜„ ì‹¤í–‰
  /vibe.verify "ê¸°ëŠ¥ëª…"          ê²€ì¦

ë‹¤ìŒ ë‹¨ê³„:
  ${isNewProject ? `cd ${projectName}\n  ` : ''}/vibe.spec "ê¸°ëŠ¥ëª…" ìœ¼ë¡œ ì‹œì‘í•˜ì„¸ìš”!
    `);

  } catch (error) {
    console.error('âŒ ì´ˆê¸°í™” ì‹¤íŒ¨:', error.message);
    process.exit(1);
  }
}

// ë„ì›€ë§ ì¶œë ¥
function showHelp() {
  console.log(`
ğŸ“– Vibe - SPEC-driven AI coding framework (Claude Code ì „ìš©)

ê¸°ë³¸ ëª…ë ¹ì–´:
  vibe init [project]     í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
  vibe update             ì„¤ì • ì—…ë°ì´íŠ¸
  vibe status             í˜„ì¬ ì„¤ì • ìƒíƒœ
  vibe help               ë„ì›€ë§
  vibe version            ë²„ì „ ì •ë³´

ì™¸ë¶€ LLM (ì„ íƒì ):
  vibe gpt <api-key>      GPT í™œì„±í™” (ì•„í‚¤í…ì²˜/ë””ë²„ê¹…)
  vibe gemini <api-key>   Gemini í™œì„±í™” (UI/UX)
  vibe gpt --remove       GPT ë¹„í™œì„±í™”
  vibe gemini --remove    Gemini ë¹„í™œì„±í™”

Claude Code ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ:
  /vibe.spec "ê¸°ëŠ¥ëª…"     SPEC ì‘ì„± (PTCF êµ¬ì¡°)
  /vibe.run "ê¸°ëŠ¥ëª…"      êµ¬í˜„ ì‹¤í–‰
  /vibe.verify "ê¸°ëŠ¥ëª…"   ê²€ì¦
  /vibe.reason "ë¬¸ì œ"     ì²´ê³„ì  ì¶”ë¡ 
  /vibe.analyze           í”„ë¡œì íŠ¸ ë¶„ì„
  /vibe.ui "ì„¤ëª…"         UI ë¯¸ë¦¬ë³´ê¸°
  /vibe.diagram           ë‹¤ì´ì–´ê·¸ë¨ ìƒì„±

ëª¨ë¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜:
  Opus 4.5    ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° (ë©”ì¸)
  Sonnet 4    êµ¬í˜„
  Haiku 4.5   ì½”ë“œ íƒìƒ‰
  GPT 5.2     ì•„í‚¤í…ì²˜/ë””ë²„ê¹… (ì„ íƒì )
  Gemini 3    UI/UX ì„¤ê³„ (ì„ íƒì )

Workflow:
  /vibe.spec â†’ /vibe.run â†’ /vibe.verify

ë¬¸ì„œ:
  https://github.com/su-record/vibe
  `);
}

// ë””ë ‰í† ë¦¬ ì‚­ì œ (ì¬ê·€)
function removeDirRecursive(dirPath) {
  if (!fs.existsSync(dirPath)) return;

  fs.readdirSync(dirPath).forEach(item => {
    const itemPath = path.join(dirPath, item);
    if (fs.statSync(itemPath).isDirectory()) {
      removeDirRecursive(itemPath);
    } else {
      fs.unlinkSync(itemPath);
    }
  });
  fs.rmdirSync(dirPath);
}

// ìµœì‹  ë²„ì „ í™•ì¸ ë° ìë™ ì—…ê·¸ë ˆì´ë“œ
async function checkAndUpgradeVibe() {
  const { execSync } = require('child_process');
  const currentVersion = require('../package.json').version;

  try {
    // npmì—ì„œ ìµœì‹  ë²„ì „ í™•ì¸
    const latestVersion = execSync('npm view @su-record/vibe version', {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();

    if (latestVersion !== currentVersion) {
      log(`   ğŸ“¦ ìƒˆ ë²„ì „ ë°œê²¬: v${currentVersion} â†’ v${latestVersion}\n`);
      log('   â¬†ï¸  vibe ì—…ê·¸ë ˆì´ë“œ ì¤‘...\n');

      execSync('npm install -g @su-record/vibe@latest', {
        stdio: options.silent ? 'pipe' : 'inherit'
      });

      log('   âœ… vibe ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ!\n');

      // ì—…ê·¸ë ˆì´ë“œ í›„ ìƒˆ ë²„ì „ìœ¼ë¡œ update ì¬ì‹¤í–‰
      log('   ğŸ”„ ìƒˆ ë²„ì „ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ì¬ì‹¤í–‰...\n\n');
      execSync(`vibe update${options.silent ? ' --silent' : ''}`, {
        stdio: 'inherit',
        cwd: process.cwd()
      });
      return true; // ì¬ì‹¤í–‰ë¨
    } else {
      log(`   âœ… ìµœì‹  ë²„ì „ ì‚¬ìš© ì¤‘ (v${currentVersion})\n`);
      return false; // ê³„ì† ì§„í–‰
    }
  } catch (e) {
    // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë“±ì€ ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
    log(`   â„¹ï¸  ë²„ì „ í™•ì¸ ìŠ¤í‚µ (ì˜¤í”„ë¼ì¸ ë˜ëŠ” ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜)\n`);
    return false;
  }
}

// í”„ë¡œì íŠ¸ ì—…ë°ì´íŠ¸
async function update() {
  try {
    const projectRoot = process.cwd();
    const vibeDir = path.join(projectRoot, '.vibe');
    const claudeDir = path.join(projectRoot, '.claude');

    if (!fs.existsSync(vibeDir)) {
      console.log('âŒ vibe í”„ë¡œì íŠ¸ê°€ ì•„ë‹™ë‹ˆë‹¤. ë¨¼ì € vibe initì„ ì‹¤í–‰í•˜ì„¸ìš”.');
      return;
    }

    log('ğŸ”„ vibe ì—…ë°ì´íŠ¸ ì¤‘...\n');

    // ìµœì‹  ë²„ì „ í™•ì¸ ë° ìë™ ì—…ê·¸ë ˆì´ë“œ
    const wasUpgraded = await checkAndUpgradeVibe();
    if (wasUpgraded) {
      return; // ìƒˆ ë²„ì „ì—ì„œ ì¬ì‹¤í–‰ë¨
    }

    // ë§ˆì´ê·¸ë ˆì´ì…˜: .agent/rules/ â†’ .vibe/rules/
    const oldRulesDir = path.join(projectRoot, '.agent/rules');
    const oldAgentDir = path.join(projectRoot, '.agent');
    if (fs.existsSync(oldRulesDir)) {
      log('   ğŸ”„ ë§ˆì´ê·¸ë ˆì´ì…˜: .agent/rules/ â†’ .vibe/rules/\n');
      removeDirRecursive(oldRulesDir);
      // .agent í´ë”ê°€ ë¹„ì–´ìˆìœ¼ë©´ ì‚­ì œ
      if (fs.existsSync(oldAgentDir) && fs.readdirSync(oldAgentDir).length === 0) {
        fs.rmdirSync(oldAgentDir);
      }
      log('   âœ… ê¸°ì¡´ .agent/rules/ í´ë” ì •ë¦¬ ì™„ë£Œ\n');
    }

    // .claude/commands ì—…ë°ì´íŠ¸
    const commandsDir = path.join(claudeDir, 'commands');
    ensureDir(commandsDir);
    const sourceDir = path.join(__dirname, '../.claude/commands');
    copyDirContents(sourceDir, commandsDir);
    log('   âœ… ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ì—…ë°ì´íŠ¸ ì™„ë£Œ (7ê°œ)\n');

    // .vibe/rules/ ì—…ë°ì´íŠ¸
    const rulesSource = path.join(__dirname, '../.vibe/rules');
    const rulesTarget = path.join(vibeDir, 'rules');
    copyDirRecursive(rulesSource, rulesTarget);
    log('   âœ… ì½”ë”© ê·œì¹™ ì—…ë°ì´íŠ¸ ì™„ë£Œ (.vibe/rules/)\n');

    // .claude/agents/ ì—…ë°ì´íŠ¸
    const agentsDir = path.join(claudeDir, 'agents');
    ensureDir(agentsDir);
    const agentsSourceDir = path.join(__dirname, '../.claude/agents');
    copyDirContents(agentsSourceDir, agentsDir);
    log('   âœ… ì„œë¸Œì—ì´ì „íŠ¸ ì—…ë°ì´íŠ¸ ì™„ë£Œ (.claude/agents/)\n');

    // settings.jsonì— hooks ë³‘í•© (ì €ì¥ì†Œ ê³µìœ ìš©)
    const settingsPath = path.join(claudeDir, 'settings.json');
    const hooksTemplate = path.join(__dirname, '../templates/hooks-template.json');

    if (fs.existsSync(hooksTemplate)) {
      const vibeHooks = JSON.parse(fs.readFileSync(hooksTemplate, 'utf-8'));

      if (fs.existsSync(settingsPath)) {
        // ê¸°ì¡´ ì„¤ì •ì— hooks ë³‘í•©
        const existingSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));

        if (!existingSettings.hooks) {
          existingSettings.hooks = vibeHooks.hooks;
          fs.writeFileSync(settingsPath, JSON.stringify(existingSettings, null, 2));
          log('   âœ… Hooks ì„¤ì • ì¶”ê°€ ì™„ë£Œ\n');
        } else {
          log('   â„¹ï¸  Hooks ì„¤ì • ì´ë¯¸ ì¡´ì¬\n');
        }
      } else {
        // ìƒˆë¡œ ìƒì„±
        fs.copyFileSync(hooksTemplate, settingsPath);
        log('   âœ… Hooks ì„¤ì • ìƒì„± ì™„ë£Œ\n');
      }
    }

    // .gitignoreì—ì„œ settings.local.json ì œê±° (ì €ì¥ì†Œ ê³µìœ  í•„ìš”)
    const gitignorePath = path.join(projectRoot, '.gitignore');
    if (fs.existsSync(gitignorePath)) {
      let gitignore = fs.readFileSync(gitignorePath, 'utf-8');
      if (gitignore.includes('settings.local.json')) {
        gitignore = gitignore.replace(/\.claude\/settings\.local\.json\n?/g, '');
        gitignore = gitignore.replace(/settings\.local\.json\n?/g, '');
        fs.writeFileSync(gitignorePath, gitignore);
        log('   âœ… .gitignoreì—ì„œ settings.local.json ì œê±° (ì €ì¥ì†Œ ê³µìœ )\n');
      }
    }

    // MCP ì„œë²„ ë“±ë¡ í™•ì¸
    const { execSync } = require('child_process');

    // 1. hi-ai MCP
    const mcpPath = path.join(__dirname, '..', 'node_modules', '@su-record', 'hi-ai', 'dist', 'index.js');
    try {
      execSync(`claude mcp add vibe node "${mcpPath}"`, { stdio: 'pipe' });
      log('   âœ… vibe MCP ë“±ë¡ ì™„ë£Œ\n');
    } catch (e) {
      // ì´ë¯¸ ë“±ë¡ë¨ - silent
    }

    // 2. Context7 MCP
    try {
      execSync('claude mcp add context7 -- npx -y @upstash/context7-mcp@latest', { stdio: 'pipe' });
      log('   âœ… Context7 MCP ë“±ë¡ ì™„ë£Œ\n');
    } catch (e) {
      // ì´ë¯¸ ë“±ë¡ë¨ - silent
    }

    const packageJson = require('../package.json');
    log(`
âœ… vibe ì—…ë°ì´íŠ¸ ì™„ë£Œ! (v${packageJson.version})

ì—…ë°ì´íŠ¸ëœ í•­ëª©:
  - ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (7ê°œ)
  - ì½”ë”© ê·œì¹™ (.vibe/rules/)
  - ì„œë¸Œì—ì´ì „íŠ¸ (.claude/agents/)
  - Hooks ì„¤ì •
  - MCP ì„œë²„

ì¶”ê°€ MCP (ì„ íƒì ):
  Exa (AI ì›¹ ê²€ìƒ‰): claude mcp add exa -e EXA_API_KEY=$EXA_API_KEY -- npx -y exa-mcp-server
    `);

  } catch (error) {
    console.error('âŒ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error.message);
    process.exit(1);
  }
}

// ì™¸ë¶€ LLM ì„¤ì • (GPT, Gemini)
function setupExternalLLM(llmType, apiKey) {
  if (!apiKey) {
    console.log(`
âŒ API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.

ì‚¬ìš©ë²•:
  vibe ${llmType} <api-key>

${llmType === 'gpt' ? 'OpenAI API í‚¤: https://platform.openai.com/api-keys' : 'Google API í‚¤: https://aistudio.google.com/apikey'}
    `);
    return;
  }

  const projectRoot = process.cwd();
  const vibeDir = path.join(projectRoot, '.vibe');
  const configPath = path.join(vibeDir, 'config.json');

  if (!fs.existsSync(vibeDir)) {
    console.log('âŒ vibe í”„ë¡œì íŠ¸ê°€ ì•„ë‹™ë‹ˆë‹¤. ë¨¼ì € vibe initì„ ì‹¤í–‰í•˜ì„¸ìš”.');
    return;
  }

  // config.json ì—…ë°ì´íŠ¸
  let config = {};
  if (fs.existsSync(configPath)) {
    config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
  }

  if (!config.models) {
    config.models = {};
  }

  const llmConfig = EXTERNAL_LLMS[llmType];
  config.models[llmType] = {
    enabled: true,
    role: llmConfig.role,
    description: llmConfig.description
  };

  fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

  // MCP ì„œë²„ ë“±ë¡ (í™˜ê²½ë³€ìˆ˜ì™€ í•¨ê»˜)
  const { execSync } = require('child_process');
  const envKey = llmConfig.envKey;

  try {
    // ê¸°ì¡´ MCP ì œê±° í›„ ì¬ë“±ë¡
    try {
      execSync(`claude mcp remove ${llmConfig.name}`, { stdio: 'pipe' });
    } catch (e) {
      // ì—†ìœ¼ë©´ ë¬´ì‹œ
    }

    // í™˜ê²½ë³€ìˆ˜ì™€ í•¨ê»˜ MCP ë“±ë¡
    execSync(`claude mcp add ${llmConfig.name} -e ${envKey}=${apiKey} -- npx -y ${llmConfig.package}`, { stdio: 'pipe' });

    console.log(`
âœ… ${llmType.toUpperCase()} í™œì„±í™” ì™„ë£Œ!

ì—­í• : ${llmConfig.description}
MCP: ${llmConfig.name}

/vibe.run ì‹¤í–‰ ì‹œ ìë™ìœ¼ë¡œ í™œìš©ë©ë‹ˆë‹¤.

ë¹„í™œì„±í™”: vibe ${llmType} --remove
    `);
  } catch (e) {
    console.log(`
âš ï¸  MCP ë“±ë¡ ì‹¤íŒ¨. ìˆ˜ë™ìœ¼ë¡œ ë“±ë¡í•˜ì„¸ìš”:

claude mcp add ${llmConfig.name} -e ${envKey}=<your-key> -- npx -y ${llmConfig.package}
    `);
  }
}

function removeExternalLLM(llmType) {
  const projectRoot = process.cwd();
  const vibeDir = path.join(projectRoot, '.vibe');
  const configPath = path.join(vibeDir, 'config.json');

  if (!fs.existsSync(vibeDir)) {
    console.log('âŒ vibe í”„ë¡œì íŠ¸ê°€ ì•„ë‹™ë‹ˆë‹¤.');
    return;
  }

  // config.json ì—…ë°ì´íŠ¸
  if (fs.existsSync(configPath)) {
    const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    if (config.models && config.models[llmType]) {
      config.models[llmType].enabled = false;
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    }
  }

  // MCP ì„œë²„ ì œê±°
  const { execSync } = require('child_process');
  const llmConfig = EXTERNAL_LLMS[llmType];

  try {
    execSync(`claude mcp remove ${llmConfig.name}`, { stdio: 'pipe' });
    console.log(`âœ… ${llmType.toUpperCase()} ë¹„í™œì„±í™” ì™„ë£Œ`);
  } catch (e) {
    console.log(`â„¹ï¸  ${llmType.toUpperCase()} MCPê°€ ë“±ë¡ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.`);
  }
}

function showStatus() {
  const projectRoot = process.cwd();
  const vibeDir = path.join(projectRoot, '.vibe');
  const configPath = path.join(vibeDir, 'config.json');

  if (!fs.existsSync(vibeDir)) {
    console.log('âŒ vibe í”„ë¡œì íŠ¸ê°€ ì•„ë‹™ë‹ˆë‹¤. ë¨¼ì € vibe initì„ ì‹¤í–‰í•˜ì„¸ìš”.');
    return;
  }

  const packageJson = require('../package.json');
  let config = { language: 'ko', models: {} };
  if (fs.existsSync(configPath)) {
    config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
  }

  const gptStatus = config.models?.gpt?.enabled ? 'âœ… í™œì„±' : 'â¬š ë¹„í™œì„±';
  const geminiStatus = config.models?.gemini?.enabled ? 'âœ… í™œì„±' : 'â¬š ë¹„í™œì„±';

  console.log(`
ğŸ“Š Vibe ìƒíƒœ (v${packageJson.version})

í”„ë¡œì íŠ¸: ${projectRoot}
ì–¸ì–´: ${config.language || 'ko'}

ëª¨ë¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Opus 4.5          ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sonnet 4          êµ¬í˜„                  â”‚
â”‚ Haiku 4.5         ì½”ë“œ íƒìƒ‰             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ GPT 5.2           ${gptStatus}  ì•„í‚¤í…ì²˜/ë””ë²„ê¹…    â”‚
â”‚ Gemini 3          ${geminiStatus}  UI/UX ì„¤ê³„        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

MCP ì„œë²„:
  vibe (hi-ai)      ê¸°ë³¸ ë„êµ¬
  context7          ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ ê²€ìƒ‰

ì™¸ë¶€ LLM ì„¤ì •:
  vibe gpt <key>      GPT í™œì„±í™” (ì•„í‚¤í…ì²˜/ë””ë²„ê¹…)
  vibe gemini <key>   Gemini í™œì„±í™” (UI/UX)
  vibe gpt --remove   GPT ë¹„í™œì„±í™”
  vibe gemini --remove Gemini ë¹„í™œì„±í™”
  `);
}

// ë²„ì „ ì •ë³´
function showVersion() {
  const packageJson = require('../package.json');
  console.log(`vibe v${packageJson.version}`);
}

// ë©”ì¸ ë¼ìš°í„°
switch (command) {
  case 'init':
    init(args[1]);
    break;

  case 'update':
    update();
    break;

  case 'gpt':
    if (args[1] === '--remove') {
      removeExternalLLM('gpt');
    } else {
      setupExternalLLM('gpt', args[1]);
    }
    break;

  case 'gemini':
    if (args[1] === '--remove') {
      removeExternalLLM('gemini');
    } else {
      setupExternalLLM('gemini', args[1]);
    }
    break;

  case 'status':
    showStatus();
    break;

  case 'version':
  case '-v':
  case '--version':
    showVersion();
    break;

  case 'help':
  case '-h':
  case '--help':
  case undefined:
    showHelp();
    break;

  default:
    console.log(`
âŒ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: ${command}

ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´:
  vibe init       í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
  vibe update     ì„¤ì • ì—…ë°ì´íŠ¸
  vibe gpt        GPT í™œì„±í™”/ë¹„í™œì„±í™”
  vibe gemini     Gemini í™œì„±í™”/ë¹„í™œì„±í™”
  vibe status     í˜„ì¬ ì„¤ì • ìƒíƒœ
  vibe help       ë„ì›€ë§
  vibe version    ë²„ì „ ì •ë³´

ì‚¬ìš©ë²•: vibe help
    `);
    process.exit(1);
}
