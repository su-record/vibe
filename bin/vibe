#!/usr/bin/env node

/**
 * vibe CLI
 * Vibe Development - SPEC-driven AI coding framework
 */

const path = require('path');
const fs = require('fs');

const args = process.argv.slice(2);
const command = args[0];

// skills í´ë” ê²½ë¡œë“¤
function getSkillsPaths() {
  const cwd = process.cwd();
  return [
    path.join(__dirname, '..', 'skills'), // vibe íŒ¨í‚¤ì§€ ë‚´ì¥ skills
    path.join(cwd, '.vibe', 'skills'),     // í”„ë¡œì íŠ¸ë³„ ì»¤ìŠ¤í…€ skills
  ];
}

// skill íŒŒì¼ íŒŒì‹± (frontmatter ì¶”ì¶œ)
function parseSkill(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);

  if (!frontmatterMatch) {
    return null;
  }

  const frontmatter = frontmatterMatch[1];

  // ê°„ë‹¨í•œ YAML íŒŒì‹±
  const meta = {};
  frontmatter.split('\n').forEach(line => {
    const [key, ...valueParts] = line.split(':');
    if (key && valueParts.length) {
      meta[key.trim()] = valueParts.join(':').trim();
    }
  });

  return { ...meta, path: filePath };
}

// ëª¨ë“  skills ìˆ˜ì§‘
function collectSkills() {
  const skills = [];
  const seen = new Set();

  getSkillsPaths().forEach(skillsPath => {
    if (!fs.existsSync(skillsPath)) return;

    const isProject = skillsPath.includes('.vibe');

    // ì¬ê·€ì ìœ¼ë¡œ .md íŒŒì¼ ì°¾ê¸°
    function walkDir(dir, category = '') {
      const items = fs.readdirSync(dir);
      items.forEach(item => {
        const itemPath = path.join(dir, item);
        const stat = fs.statSync(itemPath);

        if (stat.isDirectory()) {
          walkDir(itemPath, item);
        } else if (item.endsWith('.md')) {
          const skill = parseSkill(itemPath);
          if (skill && skill.name && !seen.has(skill.name)) {
            seen.add(skill.name);
            skills.push({
              ...skill,
              category,
              location: isProject ? 'project' : 'package'
            });
          }
        }
      });
    }

    walkDir(skillsPath);
  });

  return skills;
}

// list ëª…ë ¹ì–´
function listSkills() {
  const skills = collectSkills();

  if (skills.length === 0) {
    console.log('No skills found.');
    return;
  }

  console.log('\nAvailable Skills:\n');

  // ì¹´í…Œê³ ë¦¬ë³„ë¡œ ê·¸ë£¹í™”
  const grouped = {};
  skills.forEach(skill => {
    const cat = skill.category || 'general';
    if (!grouped[cat]) grouped[cat] = [];
    grouped[cat].push(skill);
  });

  Object.keys(grouped).sort().forEach(category => {
    console.log(`  [${category}]`);
    grouped[category].forEach(skill => {
      const loc = skill.location === 'project' ? '(project)' : '(package)';
      console.log(`    ${skill.name.padEnd(20)} ${loc}`);
      if (skill.description) {
        console.log(`      ${skill.description.slice(0, 60)}${skill.description.length > 60 ? '...' : ''}`);
      }
    });
    console.log('');
  });

  const projectCount = skills.filter(s => s.location === 'project').length;
  const packageCount = skills.filter(s => s.location === 'package').length;
  console.log(`Summary: ${packageCount} package, ${projectCount} project (${skills.length} total)`);
}

// read ëª…ë ¹ì–´
function readSkill(skillName) {
  if (!skillName) {
    console.error('Usage: vibe read <skill-name>');
    process.exit(1);
  }

  const skills = collectSkills();
  const skill = skills.find(s => s.name === skillName);

  if (!skill) {
    console.error(`Skill not found: ${skillName}`);
    console.error('\nAvailable skills:');
    skills.forEach(s => console.error(`  - ${s.name}`));
    process.exit(1);
  }

  console.log(`Reading: ${skillName}`);
  console.log(`Base directory: ${path.dirname(skill.path)}`);
  console.log('');

  // ì „ì²´ íŒŒì¼ ë‚´ìš© ì¶œë ¥
  const content = fs.readFileSync(skill.path, 'utf-8');
  console.log(content);

  console.log(`\nSkill read: ${skillName}`);
}

// sync ëª…ë ¹ì–´ - AGENTS.md ìƒì„±/ì—…ë°ì´íŠ¸
function syncSkills() {
  const cwd = process.cwd();
  const agentsPath = path.join(cwd, 'AGENTS.md');
  const skills = collectSkills();

  if (skills.length === 0) {
    console.log('No skills to sync.');
    return;
  }

  // AGENTS.md ë‚´ìš© ìƒì„±
  const skillsXml = skills.map(skill => `
<skill>
<name>${skill.name}</name>
<description>${skill.description || ''}</description>
<location>${skill.location}</location>
</skill>`).join('\n');

  const agentsContent = `# AI Agents Configuration

This file configures AI coding agents for this project.

## Workflow

\`\`\`
vibe read spec â†’ vibe read reason â†’ vibe read plan â†’ vibe read tasks â†’ vibe read run â†’ vibe read verify
     â†“                â†“                  â†“                 â†“                 â†“                â†“
  ìš”êµ¬ì‚¬í•­         ì²´ê³„ì  ì¶”ë¡          ê¸°ìˆ  ê³„íš         ì‘ì—… ë¶„í•´           ì‹¤í–‰            ê²€ì¦
\`\`\`

## Skill Usage

AI ì—ì´ì „íŠ¸ì—ê²Œ skillì„ ì‚¬ìš©í•˜ë„ë¡ ìš”ì²­í•˜ì„¸ìš”:

- "vibe read specìœ¼ë¡œ ë¡œê·¸ì¸ ê¸°ëŠ¥ ëª…ì„¸ë¥¼ ì‘ì„±í•´ì¤˜"
- "vibe read reasonìœ¼ë¡œ ì´ ë¬¸ì œë¥¼ ë¶„ì„í•´ì¤˜"
- "vibe read planìœ¼ë¡œ êµ¬í˜„ ê³„íšì„ ì„¸ì›Œì¤˜"

## Compatibility

| Agent | Supported |
|-------|-----------|
| Claude Code | âœ… Native |
| Cursor | âœ… via AGENTS.md |
| Windsurf | âœ… via AGENTS.md |
| Aider | âœ… via AGENTS.md |

<skills_system priority="1">

## Available Skills

<!-- SKILLS_TABLE_START -->
<usage>
When users ask you to perform tasks, check if any of the available skills below can help complete the task more effectively. Skills provide specialized capabilities and domain knowledge.

How to use skills:
- Invoke: Bash("vibe read <skill-name>")
- The skill content will load with detailed instructions on how to complete the task
- Base directory provided in output for resolving bundled resources

Usage notes:
- Only use skills listed in <available_skills> below
- Do not invoke a skill that is already loaded in your context
- Each skill invocation is stateless
</usage>

<available_skills>
${skillsXml}
</available_skills>
<!-- SKILLS_TABLE_END -->

</skills_system>
`;

  fs.writeFileSync(agentsPath, agentsContent);
  console.log(`âœ… Synced ${skills.length} skill(s) to AGENTS.md`);
}

// ë„ì›€ë§ ì¶œë ¥
function showHelp() {
  console.log(`
ğŸ“– Vibe - SPEC-driven AI coding framework

Commands:
  vibe init [project]     Initialize vibe in current/new project
  vibe list               List all available skills
  vibe read <skill>       Read skill content (for AI agents)
  vibe sync               Sync skills to AGENTS.md
  vibe help               Show this message

Claude Code ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (í”„ë¡œì íŠ¸ ë‚´ì—ì„œ ì‚¬ìš©):
  /vibe.spec "ê¸°ëŠ¥ëª…"     SPEC ì‘ì„± (ëŒ€í™”í˜• Q&A)
  /vibe.plan "ê¸°ëŠ¥ëª…"     ê¸°ìˆ  ê³„íš ì‘ì„±
  /vibe.tasks "ê¸°ëŠ¥ëª…"    Task ëª©ë¡ ìƒì„±
  /vibe.run "Task 1-1"    Task êµ¬í˜„
  /vibe.verify "ê¸°ëŠ¥ëª…"   ê²€ì¦
  /vibe.reason "ë¬¸ì œ"     ì²´ê³„ì  ì¶”ë¡ 
  /vibe.analyze           í”„ë¡œì íŠ¸ ë¶„ì„
  /vibe.ui "ì„¤ëª…"         UI ë¯¸ë¦¬ë³´ê¸°
  /vibe.diagram --er      ë‹¤ì´ì–´ê·¸ë¨ ìƒì„±

Workflow:
  1. vibe init (MCP ì„œë²„ ë“±ë¡ + skills ì„¤ì¹˜)
  2. vibe sync (AGENTS.md ìƒì„±)
  3. Claude Code/Cursor/Windsurfì—ì„œ skills ì‚¬ìš©

ì„¤ì¹˜:
  npm install -g @su-record/vibe

ë¬¸ì„œ:
  https://github.com/su-record/vibe
  `);
}

// ë²„ì „ ì •ë³´
function showVersion() {
  const packageJson = require('../package.json');
  console.log(`vibe v${packageJson.version}`);
}

// ì—ì´ì „íŠ¸ ì„ íƒ í”„ë¡¬í”„íŠ¸
function promptAgentSelection() {
  const readline = require('readline');

  return new Promise((resolve) => {
    console.log('\nğŸ¤– ì‚¬ìš©í•  AI ì—ì´ì „íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”:\n');
    console.log('  1. Claude Code');
    console.log('  2. Cursor');
    console.log('  3. Gemini CLI');
    console.log('  4. Antigravity');
    console.log('  5. ëª¨ë‘ ì„¤ì¹˜');
    console.log('');

    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    rl.question('ì„ íƒ (1-5, ê¸°ë³¸ê°’: 1): ', (answer) => {
      rl.close();
      const choice = answer.trim() || '1';

      const agents = {
        '1': ['claude'],
        '2': ['cursor'],
        '3': ['gemini'],
        '4': ['antigravity'],
        '5': ['claude', 'cursor', 'gemini', 'antigravity']
      };

      resolve(agents[choice] || ['claude']);
    });
  });
}

// í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
async function init(projectName) {
  let projectRoot = process.cwd();
  let isNewProject = false;

  // ìƒˆ í”„ë¡œì íŠ¸ ìƒì„± ì¼€ì´ìŠ¤
  if (projectName) {
    projectRoot = path.join(process.cwd(), projectName);

    if (fs.existsSync(projectRoot)) {
      console.log(`âŒ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤: ${projectName}/`);
      return;
    }

    console.log(`ğŸ“ ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±: ${projectName}/\n`);
    fs.mkdirSync(projectRoot, { recursive: true });
    isNewProject = true;
  }

  const vibeDir = path.join(projectRoot, '.vibe');

  if (fs.existsSync(vibeDir)) {
    console.log('âŒ .vibe/ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.');
    return;
  }

  // ì—ì´ì „íŠ¸ ì„ íƒ
  const selectedAgents = await promptAgentSelection();
  console.log(`\nì„ íƒëœ ì—ì´ì „íŠ¸: ${selectedAgents.join(', ')}\n`);

  // MCP ì„œë²„ ë“±ë¡
  console.log('ğŸ”§ MCP ì„œë²„ ì„¤ì • ì¤‘...\n');

  const { execSync } = require('child_process');
  const mcpIndexPath = path.join(__dirname, '..', 'node_modules', '@su-record', 'hi-ai', 'dist', 'index.js');

  // ì„ íƒëœ ì—ì´ì „íŠ¸ë³„ MCP ë“±ë¡
  selectedAgents.forEach(agent => {
    try {
      switch (agent) {
        case 'claude':
          console.log('1ï¸âƒ£  Claude Code MCP ë“±ë¡...');
          try {
            execSync(`claude mcp add vibe node "${mcpIndexPath}"`, { stdio: 'pipe' });
            console.log('   âœ… ì™„ë£Œ\n');
          } catch (e) {
            if (e.message.includes('already exists')) {
              console.log('   â„¹ï¸  ì´ë¯¸ ë“±ë¡ë¨\n');
            } else {
              console.log('   âš ï¸  ì‹¤íŒ¨ (ìˆ˜ë™ ë“±ë¡ í•„ìš”)\n');
            }
          }
          break;

        case 'cursor':
          console.log('2ï¸âƒ£  Cursor MCP ë“±ë¡...');
          const cursorDir = path.join(projectRoot, '.cursor');
          if (!fs.existsSync(cursorDir)) fs.mkdirSync(cursorDir, { recursive: true });
          const cursorConfig = { mcpServers: { vibe: { command: 'node', args: [mcpIndexPath] } } };
          fs.writeFileSync(path.join(cursorDir, 'mcp.json'), JSON.stringify(cursorConfig, null, 2));
          console.log('   âœ… ì™„ë£Œ\n');
          break;

        case 'gemini':
          console.log('3ï¸âƒ£  Gemini CLI MCP ë“±ë¡...');
          const geminiDir = path.join(projectRoot, '.gemini');
          if (!fs.existsSync(geminiDir)) fs.mkdirSync(geminiDir, { recursive: true });
          const geminiConfig = { mcpServers: { vibe: { command: 'node', args: [mcpIndexPath] } } };
          fs.writeFileSync(path.join(geminiDir, 'settings.json'), JSON.stringify(geminiConfig, null, 2));
          console.log('   âœ… ì™„ë£Œ\n');
          break;

        case 'antigravity':
          console.log('4ï¸âƒ£  Antigravity MCP ë“±ë¡...');
          const idxDir = path.join(projectRoot, '.idx');
          if (!fs.existsSync(idxDir)) fs.mkdirSync(idxDir, { recursive: true });
          const idxConfig = { mcpServers: { vibe: { command: 'node', args: [mcpIndexPath] } } };
          fs.writeFileSync(path.join(idxDir, 'mcp.json'), JSON.stringify(idxConfig, null, 2));
          console.log('   âœ… ì™„ë£Œ\n');
          break;
      }
    } catch (error) {
      console.log(`   âš ï¸  ${agent} ì„¤ì • ì‹¤íŒ¨\n`);
    }
  });

  // í´ë” ìƒì„±
  fs.mkdirSync(vibeDir);
  fs.mkdirSync(path.join(vibeDir, 'specs'));
  fs.mkdirSync(path.join(vibeDir, 'features'));
  fs.mkdirSync(path.join(vibeDir, 'plans'));
  fs.mkdirSync(path.join(vibeDir, 'tasks'));
  fs.mkdirSync(path.join(vibeDir, 'skills')); // í”„ë¡œì íŠ¸ë³„ ì»¤ìŠ¤í…€ skills

  // ì„ íƒëœ ì—ì´ì „íŠ¸ë³„ ì»¤ë§¨ë“œ ë³µì‚¬
  console.log('ğŸ“¦ ì»¤ë§¨ë“œ ì„¤ì¹˜ ì¤‘...\n');

  selectedAgents.forEach(agent => {
    switch (agent) {
      case 'claude':
        // Claude Code ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ë³µì‚¬
        const claudeDir = path.join(projectRoot, '.claude');
        const claudeCommandsDir = path.join(claudeDir, 'commands');
        if (!fs.existsSync(claudeDir)) fs.mkdirSync(claudeDir);
        if (!fs.existsSync(claudeCommandsDir)) fs.mkdirSync(claudeCommandsDir);

        const claudeSourceDir = path.join(__dirname, '../.claude/commands');
        if (fs.existsSync(claudeSourceDir)) {
          fs.readdirSync(claudeSourceDir).forEach(file => {
            fs.copyFileSync(
              path.join(claudeSourceDir, file),
              path.join(claudeCommandsDir, file)
            );
          });
        }
        console.log('   âœ… Claude Code ì»¤ë§¨ë“œ (9ê°œ)');
        break;

      case 'cursor':
        // Cursor ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ë³µì‚¬
        const cursorCommandsDir = path.join(projectRoot, '.cursor', 'commands');
        if (!fs.existsSync(cursorCommandsDir)) {
          fs.mkdirSync(cursorCommandsDir, { recursive: true });
        }
        const cursorSourceDir = path.join(__dirname, '../templates/cursor/commands');
        if (fs.existsSync(cursorSourceDir)) {
          fs.readdirSync(cursorSourceDir).forEach(file => {
            fs.copyFileSync(
              path.join(cursorSourceDir, file),
              path.join(cursorCommandsDir, file)
            );
          });
        }
        console.log('   âœ… Cursor ì»¤ë§¨ë“œ (9ê°œ)');
        break;

      case 'gemini':
        // Gemini CLI ì»¤ë§¨ë“œ ë³µì‚¬
        const geminiCommandsDir = path.join(projectRoot, '.gemini', 'commands', 'vibe');
        if (!fs.existsSync(geminiCommandsDir)) {
          fs.mkdirSync(geminiCommandsDir, { recursive: true });
        }
        const geminiSourceDir = path.join(__dirname, '../templates/gemini/commands/vibe');
        if (fs.existsSync(geminiSourceDir)) {
          fs.readdirSync(geminiSourceDir).forEach(file => {
            fs.copyFileSync(
              path.join(geminiSourceDir, file),
              path.join(geminiCommandsDir, file)
            );
          });
        }
        console.log('   âœ… Gemini CLI ì»¤ë§¨ë“œ (9ê°œ)');
        break;

      case 'antigravity':
        // Antigravity ì›Œí¬í”Œë¡œìš° ë³µì‚¬
        const idxDir = path.join(projectRoot, '.idx');
        if (!fs.existsSync(idxDir)) {
          fs.mkdirSync(idxDir, { recursive: true });
        }
        const antigravitySource = path.join(__dirname, '../templates/antigravity/workflows.json');
        if (fs.existsSync(antigravitySource)) {
          fs.copyFileSync(antigravitySource, path.join(idxDir, 'workflows.json'));
        }
        console.log('   âœ… Antigravity ì›Œí¬í”Œë¡œìš° (9ê°œ)');
        break;
    }
  });

  console.log('');

  // constitution.md í…œí”Œë¦¿ ë³µì‚¬
  const templatePath = path.join(__dirname, '../templates/constitution-template.md');
  const constitutionPath = path.join(vibeDir, 'constitution.md');

  if (fs.existsSync(templatePath)) {
    fs.copyFileSync(templatePath, constitutionPath);
  }

  // config.json ìƒì„± (ì–¸ì–´ ì„¤ì • í¬í•¨)
  const configPath = path.join(vibeDir, 'config.json');
  const config = {
    language: 'ko',
    agents: {
      default: 'backend-python-expert'
    },
    mcp: {
      enabled: true,
      servers: ['vibe']
    },
    quality: {
      strict: true,
      autoVerify: true
    }
  };
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

  // AGENTS.md ìƒì„±
  const originalCwd = process.cwd();
  process.chdir(projectRoot);
  syncSkills();
  process.chdir(originalCwd);

  // ì„ íƒëœ ì—ì´ì „íŠ¸ì— ë§ëŠ” êµ¬ì¡° í‘œì‹œ
  const agentDirs = {
    claude: '  .claude/commands/            # Claude Code ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (9ê°œ)',
    cursor: '  .cursor/commands/            # Cursor ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (9ê°œ)',
    gemini: '  .gemini/commands/vibe/       # Gemini CLI ì»¤ë§¨ë“œ (9ê°œ)',
    antigravity: '  .idx/workflows.json          # Antigravity ì›Œí¬í”Œë¡œìš° (9ê°œ)'
  };

  const agentCommands = {
    claude: '  /vibe.spec "ê¸°ëŠ¥ëª…"          (Claude Code)',
    cursor: '  /vibe.spec "ê¸°ëŠ¥ëª…"          (Cursor)',
    gemini: '  /vibe:spec "ê¸°ëŠ¥ëª…"          (Gemini CLI)',
    antigravity: '  /vibe.spec (ì›Œí¬í”Œë¡œìš°)       (Antigravity)'
  };

  const selectedDirs = selectedAgents.map(a => agentDirs[a]).join('\n');
  const selectedCommands = selectedAgents.map(a => agentCommands[a]).join('\n');

  console.log(`
âœ… vibe ì´ˆê¸°í™” ì™„ë£Œ!

${isNewProject ? `í”„ë¡œì íŠ¸ ìœ„ì¹˜:
  ${projectRoot}/

` : ''}ìƒì„±ëœ êµ¬ì¡°:
  AGENTS.md                    # AI ì—ì´ì „íŠ¸ ì„¤ì • (ë²”ìš©)
${selectedDirs}
  .vibe/
  â”œâ”€â”€ config.json              # í”„ë¡œì íŠ¸ ì„¤ì •
  â”œâ”€â”€ constitution.md          # í”„ë¡œì íŠ¸ ì›ì¹™
  â”œâ”€â”€ specs/                   # SPEC ë¬¸ì„œë“¤
  â”œâ”€â”€ features/                # BDD Feature íŒŒì¼ë“¤
  â”œâ”€â”€ plans/                   # ê¸°ìˆ  ê³„íšë“¤
  â”œâ”€â”€ tasks/                   # ì‘ì—… ëª©ë¡ë“¤
  â””â”€â”€ skills/                  # ì»¤ìŠ¤í…€ skills

MCP ì„œë²„ (38ê°œ ë„êµ¬): âœ“

ì‚¬ìš©ë²•:
${selectedCommands}

ë‹¤ìŒ ë‹¨ê³„:
  ${isNewProject ? `cd ${projectName}\n  ` : ''}/vibe.spec "ê¸°ëŠ¥ëª…" ìœ¼ë¡œ ì‹œì‘í•˜ì„¸ìš”!
  `);
}


// ë©”ì¸ ë¼ìš°í„°
switch (command) {
  case 'init':
    init(args[1]);
    break;

  case 'list':
    listSkills();
    break;

  case 'read':
    readSkill(args[1]);
    break;

  case 'sync':
    syncSkills();
    break;

  case 'version':
  case '-v':
  case '--version':
    showVersion();
    break;

  case 'help':
  case '-h':
  case '--help':
  case undefined:
    showHelp();
    break;

  default:
    console.log(`
âŒ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: ${command}

ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´:
  vibe init       í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
  vibe list       skills ëª©ë¡
  vibe read       skill ì½ê¸°
  vibe sync       AGENTS.md ë™ê¸°í™”
  vibe help       ë„ì›€ë§

ì‚¬ìš©ë²•: vibe help
    `);
    process.exit(1);
}
