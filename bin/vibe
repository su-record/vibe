#!/usr/bin/env node

/**
 * vibe CLI
 * Vibe Development - SPEC-driven AI coding framework
 */

const path = require('path');
const fs = require('fs');

const args = process.argv.slice(2);
const command = args[0];

// skills í´ë” ê²½ë¡œë“¤
function getSkillsPaths() {
  const cwd = process.cwd();
  return [
    path.join(__dirname, '..', 'skills'), // vibe íŒ¨í‚¤ì§€ ë‚´ì¥ skills
    path.join(cwd, '.vibe', 'skills'),     // í”„ë¡œì íŠ¸ë³„ ì»¤ìŠ¤í…€ skills
  ];
}

// skill íŒŒì¼ íŒŒì‹± (frontmatter ì¶”ì¶œ)
function parseSkill(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);

  if (!frontmatterMatch) {
    return null;
  }

  const frontmatter = frontmatterMatch[1];

  // ê°„ë‹¨í•œ YAML íŒŒì‹±
  const meta = {};
  frontmatter.split('\n').forEach(line => {
    const [key, ...valueParts] = line.split(':');
    if (key && valueParts.length) {
      meta[key.trim()] = valueParts.join(':').trim();
    }
  });

  return { ...meta, path: filePath };
}

// ëª¨ë“  skills ìˆ˜ì§‘
function collectSkills() {
  const skills = [];
  const seen = new Set();

  getSkillsPaths().forEach(skillsPath => {
    if (!fs.existsSync(skillsPath)) return;

    const isProject = skillsPath.includes('.vibe');

    // ì¬ê·€ì ìœ¼ë¡œ .md íŒŒì¼ ì°¾ê¸°
    function walkDir(dir, category = '') {
      const items = fs.readdirSync(dir);
      items.forEach(item => {
        const itemPath = path.join(dir, item);
        const stat = fs.statSync(itemPath);

        if (stat.isDirectory()) {
          walkDir(itemPath, item);
        } else if (item.endsWith('.md')) {
          const skill = parseSkill(itemPath);
          if (skill && skill.name && !seen.has(skill.name)) {
            seen.add(skill.name);
            skills.push({
              ...skill,
              category,
              location: isProject ? 'project' : 'package'
            });
          }
        }
      });
    }

    walkDir(skillsPath);
  });

  return skills;
}

// list ëª…ë ¹ì–´
function listSkills() {
  const skills = collectSkills();

  if (skills.length === 0) {
    console.log('No skills found.');
    return;
  }

  console.log('\nAvailable Skills:\n');

  // ì¹´í…Œê³ ë¦¬ë³„ë¡œ ê·¸ë£¹í™”
  const grouped = {};
  skills.forEach(skill => {
    const cat = skill.category || 'general';
    if (!grouped[cat]) grouped[cat] = [];
    grouped[cat].push(skill);
  });

  Object.keys(grouped).sort().forEach(category => {
    console.log(`  [${category}]`);
    grouped[category].forEach(skill => {
      const loc = skill.location === 'project' ? '(project)' : '(package)';
      console.log(`    ${skill.name.padEnd(20)} ${loc}`);
      if (skill.description) {
        console.log(`      ${skill.description.slice(0, 60)}${skill.description.length > 60 ? '...' : ''}`);
      }
    });
    console.log('');
  });

  const projectCount = skills.filter(s => s.location === 'project').length;
  const packageCount = skills.filter(s => s.location === 'package').length;
  console.log(`Summary: ${packageCount} package, ${projectCount} project (${skills.length} total)`);
}

// read ëª…ë ¹ì–´
function readSkill(skillName) {
  if (!skillName) {
    console.error('Usage: vibe read <skill-name>');
    process.exit(1);
  }

  const skills = collectSkills();
  const skill = skills.find(s => s.name === skillName);

  if (!skill) {
    console.error(`Skill not found: ${skillName}`);
    console.error('\nAvailable skills:');
    skills.forEach(s => console.error(`  - ${s.name}`));
    process.exit(1);
  }

  console.log(`Reading: ${skillName}`);
  console.log(`Base directory: ${path.dirname(skill.path)}`);
  console.log('');

  // ì „ì²´ íŒŒì¼ ë‚´ìš© ì¶œë ¥
  const content = fs.readFileSync(skill.path, 'utf-8');
  console.log(content);

  console.log(`\nSkill read: ${skillName}`);
}

// sync ëª…ë ¹ì–´ - AGENTS.md ìƒì„±/ì—…ë°ì´íŠ¸
function syncSkills() {
  const cwd = process.cwd();
  const agentsPath = path.join(cwd, 'AGENTS.md');
  const skills = collectSkills();

  if (skills.length === 0) {
    console.log('No skills to sync.');
    return;
  }

  // AGENTS.md ë‚´ìš© ìƒì„±
  const skillsXml = skills.map(skill => `
<skill>
<name>${skill.name}</name>
<description>${skill.description || ''}</description>
<location>${skill.location}</location>
</skill>`).join('\n');

  const agentsContent = `# AI Agents Configuration

This file configures AI coding agents for this project.

## Workflow

\`\`\`
vibe read spec â†’ vibe read reason â†’ vibe read plan â†’ vibe read tasks â†’ vibe read run â†’ vibe read verify
     â†“                â†“                  â†“                 â†“                 â†“                â†“
  ìš”êµ¬ì‚¬í•­         ì²´ê³„ì  ì¶”ë¡          ê¸°ìˆ  ê³„íš         ì‘ì—… ë¶„í•´           ì‹¤í–‰            ê²€ì¦
\`\`\`

## Skill Usage

AI ì—ì´ì „íŠ¸ì—ê²Œ skillì„ ì‚¬ìš©í•˜ë„ë¡ ìš”ì²­í•˜ì„¸ìš”:

- "vibe read specìœ¼ë¡œ ë¡œê·¸ì¸ ê¸°ëŠ¥ ëª…ì„¸ë¥¼ ì‘ì„±í•´ì¤˜"
- "vibe read reasonìœ¼ë¡œ ì´ ë¬¸ì œë¥¼ ë¶„ì„í•´ì¤˜"
- "vibe read planìœ¼ë¡œ êµ¬í˜„ ê³„íšì„ ì„¸ì›Œì¤˜"

## Compatibility

| Agent | Supported |
|-------|-----------|
| Claude Code | âœ… Native |
| Cursor | âœ… via AGENTS.md |
| Windsurf | âœ… via AGENTS.md |
| Aider | âœ… via AGENTS.md |

<skills_system priority="1">

## Available Skills

<!-- SKILLS_TABLE_START -->
<usage>
When users ask you to perform tasks, check if any of the available skills below can help complete the task more effectively. Skills provide specialized capabilities and domain knowledge.

How to use skills:
- Invoke: Bash("vibe read <skill-name>")
- The skill content will load with detailed instructions on how to complete the task
- Base directory provided in output for resolving bundled resources

Usage notes:
- Only use skills listed in <available_skills> below
- Do not invoke a skill that is already loaded in your context
- Each skill invocation is stateless
</usage>

<available_skills>
${skillsXml}
</available_skills>
<!-- SKILLS_TABLE_END -->

</skills_system>
`;

  fs.writeFileSync(agentsPath, agentsContent);
  console.log(`âœ… Synced ${skills.length} skill(s) to AGENTS.md`);
}

// ë„ì›€ë§ ì¶œë ¥
function showHelp() {
  console.log(`
ğŸ“– Vibe - SPEC-driven AI coding framework

Commands:
  vibe init [project]     Initialize vibe in current/new project
  vibe list               List all available skills
  vibe read <skill>       Read skill content (for AI agents)
  vibe sync               Sync skills to AGENTS.md
  vibe help               Show this message

Claude Code ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (í”„ë¡œì íŠ¸ ë‚´ì—ì„œ ì‚¬ìš©):
  /vibe.spec "ê¸°ëŠ¥ëª…"     SPEC ì‘ì„± (ëŒ€í™”í˜• Q&A)
  /vibe.plan "ê¸°ëŠ¥ëª…"     ê¸°ìˆ  ê³„íš ì‘ì„±
  /vibe.tasks "ê¸°ëŠ¥ëª…"    Task ëª©ë¡ ìƒì„±
  /vibe.run "Task 1-1"    Task êµ¬í˜„
  /vibe.verify "ê¸°ëŠ¥ëª…"   ê²€ì¦
  /vibe.reason "ë¬¸ì œ"     ì²´ê³„ì  ì¶”ë¡ 
  /vibe.analyze           í”„ë¡œì íŠ¸ ë¶„ì„
  /vibe.ui "ì„¤ëª…"         UI ë¯¸ë¦¬ë³´ê¸°
  /vibe.diagram --er      ë‹¤ì´ì–´ê·¸ë¨ ìƒì„±

Workflow:
  1. vibe init (MCP ì„œë²„ ë“±ë¡ + skills ì„¤ì¹˜)
  2. vibe sync (AGENTS.md ìƒì„±)
  3. Claude Code/Cursor/Windsurfì—ì„œ skills ì‚¬ìš©

ì„¤ì¹˜:
  npm install -g @su-record/vibe

ë¬¸ì„œ:
  https://github.com/su-record/vibe
  `);
}

// ë²„ì „ ì •ë³´
function showVersion() {
  const packageJson = require('../package.json');
  console.log(`vibe v${packageJson.version}`);
}

// ============================================
// ì—ì´ì „íŠ¸ ì„¤ì • (í…Œì´ë¸” ê¸°ë°˜)
// ============================================

const AGENT_CONFIGS = {
  claude: {
    label: 'Claude Code',
    emoji: '1ï¸âƒ£',
    setupMcp: (projectRoot, mcpPath) => {
      const { execSync } = require('child_process');
      try {
        execSync(`claude mcp add vibe node "${mcpPath}"`, { stdio: 'pipe' });
        return { success: true };
      } catch (e) {
        if (e.message.includes('already exists')) {
          return { success: true, message: 'ì´ë¯¸ ë“±ë¡ë¨' };
        }
        return { success: false, message: 'ìˆ˜ë™ ë“±ë¡ í•„ìš”' };
      }
    },
    copyCommands: (projectRoot, templatesDir) => {
      const claudeDir = path.join(projectRoot, '.claude');
      const commandsDir = path.join(claudeDir, 'commands');
      ensureDir(claudeDir);
      ensureDir(commandsDir);

      const sourceDir = path.join(templatesDir, '../.claude/commands');
      copyDirContents(sourceDir, commandsDir);
      return 9;
    },
    getDirInfo: () => '  .claude/commands/            # Claude Code ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (9ê°œ)',
    getCommandInfo: () => '  /vibe.spec "ê¸°ëŠ¥ëª…"          (Claude Code)'
  },

  cursor: {
    label: 'Cursor',
    emoji: '2ï¸âƒ£',
    setupMcp: (projectRoot, mcpPath) => {
      const cursorDir = path.join(projectRoot, '.cursor');
      ensureDir(cursorDir);
      const config = { mcpServers: { vibe: { command: 'node', args: [mcpPath] } } };
      fs.writeFileSync(path.join(cursorDir, 'mcp.json'), JSON.stringify(config, null, 2));
      return { success: true };
    },
    copyCommands: (projectRoot, templatesDir) => {
      const commandsDir = path.join(projectRoot, '.cursor', 'commands');
      ensureDir(commandsDir);

      const sourceDir = path.join(templatesDir, 'cursor/commands');
      copyDirContents(sourceDir, commandsDir);
      return 9;
    },
    getDirInfo: () => '  .cursor/commands/            # Cursor ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (9ê°œ)',
    getCommandInfo: () => '  /vibe.spec "ê¸°ëŠ¥ëª…"          (Cursor)'
  },

  gemini: {
    label: 'Gemini CLI',
    emoji: '3ï¸âƒ£',
    setupMcp: (projectRoot, mcpPath) => {
      const geminiDir = path.join(projectRoot, '.gemini');
      ensureDir(geminiDir);
      const config = { mcpServers: { vibe: { command: 'node', args: [mcpPath] } } };
      fs.writeFileSync(path.join(geminiDir, 'settings.json'), JSON.stringify(config, null, 2));
      return { success: true };
    },
    copyCommands: (projectRoot, templatesDir) => {
      const commandsDir = path.join(projectRoot, '.gemini', 'commands', 'vibe');
      ensureDir(commandsDir);

      const sourceDir = path.join(templatesDir, 'gemini/commands/vibe');
      copyDirContents(sourceDir, commandsDir);
      return 9;
    },
    getDirInfo: () => '  .gemini/commands/vibe/       # Gemini CLI ì»¤ë§¨ë“œ (9ê°œ)',
    getCommandInfo: () => '  /vibe:spec "ê¸°ëŠ¥ëª…"          (Gemini CLI)'
  },

  antigravity: {
    label: 'Antigravity',
    emoji: '4ï¸âƒ£',
    setupMcp: (projectRoot, mcpPath) => {
      const idxDir = path.join(projectRoot, '.idx');
      ensureDir(idxDir);
      const config = { mcpServers: { vibe: { command: 'node', args: [mcpPath] } } };
      fs.writeFileSync(path.join(idxDir, 'mcp.json'), JSON.stringify(config, null, 2));
      return { success: true };
    },
    copyCommands: (projectRoot, templatesDir) => {
      const idxDir = path.join(projectRoot, '.idx');
      ensureDir(idxDir);

      const sourceFile = path.join(templatesDir, 'antigravity/workflows.json');
      if (fs.existsSync(sourceFile)) {
        fs.copyFileSync(sourceFile, path.join(idxDir, 'workflows.json'));
      }
      return 9;
    },
    getDirInfo: () => '  .idx/workflows.json          # Antigravity ì›Œí¬í”Œë¡œìš° (9ê°œ)',
    getCommandInfo: () => '  /vibe.spec (ì›Œí¬í”Œë¡œìš°)       (Antigravity)'
  }
};

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function copyDirContents(sourceDir, targetDir) {
  if (fs.existsSync(sourceDir)) {
    fs.readdirSync(sourceDir).forEach(file => {
      fs.copyFileSync(path.join(sourceDir, file), path.join(targetDir, file));
    });
  }
}

// ì—ì´ì „íŠ¸ ì„ íƒ í”„ë¡¬í”„íŠ¸
function promptAgentSelection() {
  const readline = require('readline');

  return new Promise((resolve) => {
    console.log('\nğŸ¤– ì‚¬ìš©í•  AI ì—ì´ì „íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”:\n');
    console.log('  1. Claude Code');
    console.log('  2. Cursor');
    console.log('  3. Gemini CLI');
    console.log('  4. Antigravity');
    console.log('  5. ëª¨ë‘ ì„¤ì¹˜');
    console.log('');

    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    rl.question('ì„ íƒ (1-5, ê¸°ë³¸ê°’: 1): ', (answer) => {
      rl.close();
      const choice = answer.trim() || '1';

      const agents = {
        '1': ['claude'],
        '2': ['cursor'],
        '3': ['gemini'],
        '4': ['antigravity'],
        '5': ['claude', 'cursor', 'gemini', 'antigravity']
      };

      resolve(agents[choice] || ['claude']);
    });
  });
}

// í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
async function init(projectName) {
  try {
    const { projectRoot, isNewProject } = setupProjectRoot(projectName);
    if (!projectRoot) return;

    const vibeDir = path.join(projectRoot, '.vibe');
    if (fs.existsSync(vibeDir)) {
      console.log('âŒ .vibe/ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.');
      return;
    }

    // ì—ì´ì „íŠ¸ ì„ íƒ
    const selectedAgents = await promptAgentSelection();
    console.log(`\nì„ íƒëœ ì—ì´ì „íŠ¸: ${selectedAgents.join(', ')}\n`);

    // MCP ì„œë²„ ë“±ë¡
    const mcpPath = path.join(__dirname, '..', 'node_modules', '@su-record', 'hi-ai', 'dist', 'index.js');
    const templatesDir = path.join(__dirname, '../templates');

    console.log('ğŸ”§ MCP ì„œë²„ ì„¤ì • ì¤‘...\n');
    setupAgentsMcp(selectedAgents, projectRoot, mcpPath);

    // .vibe í´ë” êµ¬ì¡° ìƒì„±
    createVibeStructure(vibeDir);

    // ì»¤ë§¨ë“œ ë³µì‚¬
    console.log('ğŸ“¦ ì»¤ë§¨ë“œ ì„¤ì¹˜ ì¤‘...\n');
    copyAgentCommands(selectedAgents, projectRoot, templatesDir);
    console.log('');

    // ì„¤ì • íŒŒì¼ ìƒì„±
    createConfigFiles(vibeDir, projectRoot);

    // ì™„ë£Œ ë©”ì‹œì§€ ì¶œë ¥
    printCompletionMessage(selectedAgents, projectRoot, isNewProject, projectName);

  } catch (error) {
    console.error('âŒ ì´ˆê¸°í™” ì‹¤íŒ¨:', error.message);
    process.exit(1);
  }
}

// í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì„¤ì •
function setupProjectRoot(projectName) {
  let projectRoot = process.cwd();
  let isNewProject = false;

  if (projectName) {
    projectRoot = path.join(process.cwd(), projectName);

    if (fs.existsSync(projectRoot)) {
      console.log(`âŒ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤: ${projectName}/`);
      return { projectRoot: null };
    }

    console.log(`ğŸ“ ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±: ${projectName}/\n`);
    fs.mkdirSync(projectRoot, { recursive: true });
    isNewProject = true;
  }

  return { projectRoot, isNewProject };
}

// ì—ì´ì „íŠ¸ë³„ MCP ì„¤ì •
function setupAgentsMcp(agents, projectRoot, mcpPath) {
  agents.forEach(agentName => {
    const config = AGENT_CONFIGS[agentName];
    if (!config) return;

    console.log(`${config.emoji}  ${config.label} MCP ë“±ë¡...`);
    const result = config.setupMcp(projectRoot, mcpPath);

    if (result.success) {
      console.log(result.message ? `   â„¹ï¸  ${result.message}\n` : '   âœ… ì™„ë£Œ\n');
    } else {
      console.log(`   âš ï¸  ${result.message || 'ì‹¤íŒ¨'}\n`);
    }
  });
}

// .vibe í´ë” êµ¬ì¡° ìƒì„±
function createVibeStructure(vibeDir) {
  const dirs = ['', 'specs', 'features', 'plans', 'tasks', 'skills'];
  dirs.forEach(dir => {
    ensureDir(path.join(vibeDir, dir));
  });
}

// ì—ì´ì „íŠ¸ë³„ ì»¤ë§¨ë“œ ë³µì‚¬
function copyAgentCommands(agents, projectRoot, templatesDir) {
  agents.forEach(agentName => {
    const config = AGENT_CONFIGS[agentName];
    if (!config) return;

    config.copyCommands(projectRoot, templatesDir);
    console.log(`   âœ… ${config.label} ì»¤ë§¨ë“œ (9ê°œ)`);
  });
}

// ì„¤ì • íŒŒì¼ ìƒì„±
function createConfigFiles(vibeDir, projectRoot) {
  // constitution.md í…œí”Œë¦¿ ë³µì‚¬
  const templatePath = path.join(__dirname, '../templates/constitution-template.md');
  const constitutionPath = path.join(vibeDir, 'constitution.md');
  if (fs.existsSync(templatePath)) {
    fs.copyFileSync(templatePath, constitutionPath);
  }

  // config.json ìƒì„±
  const config = {
    language: 'ko',
    agents: { default: 'backend-python-expert' },
    mcp: { enabled: true, servers: ['vibe'] },
    quality: { strict: true, autoVerify: true }
  };
  fs.writeFileSync(path.join(vibeDir, 'config.json'), JSON.stringify(config, null, 2));

  // AGENTS.md ìƒì„±
  const originalCwd = process.cwd();
  process.chdir(projectRoot);
  syncSkills();
  process.chdir(originalCwd);
}

// ì™„ë£Œ ë©”ì‹œì§€ ì¶œë ¥
function printCompletionMessage(selectedAgents, projectRoot, isNewProject, projectName) {
  const selectedDirs = selectedAgents.map(a => AGENT_CONFIGS[a]?.getDirInfo()).filter(Boolean).join('\n');
  const selectedCommands = selectedAgents.map(a => AGENT_CONFIGS[a]?.getCommandInfo()).filter(Boolean).join('\n');

  console.log(`
âœ… vibe ì´ˆê¸°í™” ì™„ë£Œ!

${isNewProject ? `í”„ë¡œì íŠ¸ ìœ„ì¹˜:
  ${projectRoot}/

` : ''}ìƒì„±ëœ êµ¬ì¡°:
  AGENTS.md                    # AI ì—ì´ì „íŠ¸ ì„¤ì • (ë²”ìš©)
${selectedDirs}
  .vibe/
  â”œâ”€â”€ config.json              # í”„ë¡œì íŠ¸ ì„¤ì •
  â”œâ”€â”€ constitution.md          # í”„ë¡œì íŠ¸ ì›ì¹™
  â”œâ”€â”€ specs/                   # SPEC ë¬¸ì„œë“¤
  â”œâ”€â”€ features/                # BDD Feature íŒŒì¼ë“¤
  â”œâ”€â”€ plans/                   # ê¸°ìˆ  ê³„íšë“¤
  â”œâ”€â”€ tasks/                   # ì‘ì—… ëª©ë¡ë“¤
  â””â”€â”€ skills/                  # ì»¤ìŠ¤í…€ skills

MCP ì„œë²„ (38ê°œ ë„êµ¬): âœ“

ì‚¬ìš©ë²•:
${selectedCommands}

ë‹¤ìŒ ë‹¨ê³„:
  ${isNewProject ? `cd ${projectName}\n  ` : ''}/vibe.spec "ê¸°ëŠ¥ëª…" ìœ¼ë¡œ ì‹œì‘í•˜ì„¸ìš”!
  `);
}


// ë©”ì¸ ë¼ìš°í„°
switch (command) {
  case 'init':
    init(args[1]);
    break;

  case 'list':
    listSkills();
    break;

  case 'read':
    readSkill(args[1]);
    break;

  case 'sync':
    syncSkills();
    break;

  case 'version':
  case '-v':
  case '--version':
    showVersion();
    break;

  case 'help':
  case '-h':
  case '--help':
  case undefined:
    showHelp();
    break;

  default:
    console.log(`
âŒ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: ${command}

ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´:
  vibe init       í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
  vibe list       skills ëª©ë¡
  vibe read       skill ì½ê¸°
  vibe sync       AGENTS.md ë™ê¸°í™”
  vibe help       ë„ì›€ë§

ì‚¬ìš©ë²•: vibe help
    `);
    process.exit(1);
}
