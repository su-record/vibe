#!/usr/bin/env node

/**
 * vibe CLI
 * SPEC-driven AI coding framework (Claude Code ì „ìš©)
 */

const path = require('path');
const fs = require('fs');

const args = process.argv.slice(2);
const command = args[0];

// ì˜µì…˜ íŒŒì‹±
const options = {
  silent: args.includes('--silent') || args.includes('-s')
};

// ì˜µì…˜ì´ ì•„ë‹Œ ì¸ìë“¤ë§Œ í•„í„°ë§ (í”„ë¡œì íŠ¸ ì´ë¦„ ë“±)
const positionalArgs = args.filter(arg => !arg.startsWith('-'));

// MCP ì„¤ì •
const DEFAULT_MCPS = [
  { name: 'vibe', type: 'node', local: true },
  { name: 'context7', type: 'npx', package: '@upstash/context7-mcp@latest' }
];

const EXTERNAL_LLMS = {
  gpt: {
    name: 'vibe-gpt',
    role: 'architecture',
    description: 'ì•„í‚¤í…ì²˜/ë””ë²„ê¹… (GPT 5.2)',
    package: '@anthropics/openai-mcp',
    envKey: 'OPENAI_API_KEY'
  },
  gemini: {
    name: 'vibe-gemini',
    role: 'ui-ux',
    description: 'UI/UX ì„¤ê³„ (Gemini 3)',
    package: '@anthropics/gemini-mcp',
    envKey: 'GOOGLE_API_KEY'
  }
};

// ë¡œê·¸ í•¨ìˆ˜ (silent ëª¨ë“œ ì§€ì›)
function log(message) {
  if (!options.silent) {
    console.log(message);
  }
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function copyDirContents(sourceDir, targetDir) {
  if (fs.existsSync(sourceDir)) {
    fs.readdirSync(sourceDir).forEach(file => {
      fs.copyFileSync(path.join(sourceDir, file), path.join(targetDir, file));
    });
  }
}

function copyDirRecursive(sourceDir, targetDir) {
  if (!fs.existsSync(sourceDir)) return;

  ensureDir(targetDir);

  fs.readdirSync(sourceDir).forEach(item => {
    const sourcePath = path.join(sourceDir, item);
    const targetPath = path.join(targetDir, item);

    if (fs.statSync(sourcePath).isDirectory()) {
      copyDirRecursive(sourcePath, targetPath);
    } else {
      fs.copyFileSync(sourcePath, targetPath);
    }
  });
}

// ê¸°ìˆ  ìŠ¤íƒ ê°ì§€ (ë£¨íŠ¸ + 1ë ˆë²¨ í•˜ìœ„ í´ë”) - ì‹¤ì œ ì˜ì¡´ì„± ê¸°ë°˜
function detectTechStacks(projectRoot) {
  const stacks = [];
  const details = { databases: [], stateManagement: [], hosting: [], cicd: [] };

  const detectInDir = (dir, prefix = '') => {
    const detected = [];

    // Node.js / TypeScript
    if (fs.existsSync(path.join(dir, 'package.json'))) {
      try {
        const pkg = JSON.parse(fs.readFileSync(path.join(dir, 'package.json'), 'utf-8'));
        const deps = { ...pkg.dependencies, ...pkg.devDependencies };

        // í”„ë ˆì„ì›Œí¬ ê°ì§€
        if (deps['next']) detected.push({ type: 'typescript-nextjs', path: prefix });
        else if (deps['react-native']) detected.push({ type: 'typescript-react-native', path: prefix });
        else if (deps['react']) detected.push({ type: 'typescript-react', path: prefix });
        else if (deps['vue']) detected.push({ type: 'typescript-vue', path: prefix });
        else if (deps['express'] || deps['fastify'] || deps['koa']) detected.push({ type: 'typescript-node', path: prefix });
        else if (pkg.name) detected.push({ type: 'typescript-node', path: prefix });

        // DB ê°ì§€
        if (deps['pg'] || deps['postgres'] || deps['@prisma/client']) details.databases.push('PostgreSQL');
        if (deps['mysql'] || deps['mysql2']) details.databases.push('MySQL');
        if (deps['mongodb'] || deps['mongoose']) details.databases.push('MongoDB');
        if (deps['redis'] || deps['ioredis']) details.databases.push('Redis');
        if (deps['sqlite3'] || deps['better-sqlite3']) details.databases.push('SQLite');
        if (deps['typeorm']) details.databases.push('TypeORM');
        if (deps['prisma'] || deps['@prisma/client']) details.databases.push('Prisma');
        if (deps['drizzle-orm']) details.databases.push('Drizzle');
        if (deps['sequelize']) details.databases.push('Sequelize');

        // ìƒíƒœê´€ë¦¬ ê°ì§€
        if (deps['redux'] || deps['@reduxjs/toolkit']) details.stateManagement.push('Redux');
        if (deps['zustand']) details.stateManagement.push('Zustand');
        if (deps['jotai']) details.stateManagement.push('Jotai');
        if (deps['recoil']) details.stateManagement.push('Recoil');
        if (deps['mobx']) details.stateManagement.push('MobX');
        if (deps['@tanstack/react-query'] || deps['react-query']) details.stateManagement.push('React Query');
        if (deps['swr']) details.stateManagement.push('SWR');
        if (deps['pinia']) details.stateManagement.push('Pinia');
        if (deps['vuex']) details.stateManagement.push('Vuex');
      } catch (e) {}
    }

    // Python
    if (fs.existsSync(path.join(dir, 'pyproject.toml'))) {
      try {
        const content = fs.readFileSync(path.join(dir, 'pyproject.toml'), 'utf-8');
        if (content.includes('fastapi')) detected.push({ type: 'python-fastapi', path: prefix });
        else if (content.includes('django')) detected.push({ type: 'python-django', path: prefix });
        else detected.push({ type: 'python', path: prefix });

        // Python DB
        if (content.includes('psycopg') || content.includes('asyncpg')) details.databases.push('PostgreSQL');
        if (content.includes('pymongo')) details.databases.push('MongoDB');
        if (content.includes('sqlalchemy')) details.databases.push('SQLAlchemy');
        if (content.includes('prisma')) details.databases.push('Prisma');
      } catch (e) {}
    } else if (fs.existsSync(path.join(dir, 'requirements.txt'))) {
      try {
        const content = fs.readFileSync(path.join(dir, 'requirements.txt'), 'utf-8');
        if (content.includes('fastapi')) detected.push({ type: 'python-fastapi', path: prefix });
        else if (content.includes('django')) detected.push({ type: 'python-django', path: prefix });
        else detected.push({ type: 'python', path: prefix });

        if (content.includes('psycopg') || content.includes('asyncpg')) details.databases.push('PostgreSQL');
        if (content.includes('pymongo')) details.databases.push('MongoDB');
        if (content.includes('sqlalchemy')) details.databases.push('SQLAlchemy');
      } catch (e) {}
    }

    // Flutter / Dart
    if (fs.existsSync(path.join(dir, 'pubspec.yaml'))) {
      detected.push({ type: 'dart-flutter', path: prefix });
      try {
        const content = fs.readFileSync(path.join(dir, 'pubspec.yaml'), 'utf-8');
        if (content.includes('flutter_riverpod') || content.includes('riverpod')) details.stateManagement.push('Riverpod');
        else if (content.includes('provider')) details.stateManagement.push('Provider');
        if (content.includes('bloc')) details.stateManagement.push('BLoC');
        if (content.includes('getx') || content.includes('get:')) details.stateManagement.push('GetX');
      } catch (e) {}
    }

    // Go
    if (fs.existsSync(path.join(dir, 'go.mod'))) {
      detected.push({ type: 'go', path: prefix });
      try {
        const content = fs.readFileSync(path.join(dir, 'go.mod'), 'utf-8');
        if (content.includes('pgx') || content.includes('pq')) details.databases.push('PostgreSQL');
        if (content.includes('go-redis')) details.databases.push('Redis');
        if (content.includes('mongo-driver')) details.databases.push('MongoDB');
      } catch (e) {}
    }

    // Rust
    if (fs.existsSync(path.join(dir, 'Cargo.toml'))) {
      detected.push({ type: 'rust', path: prefix });
      try {
        const content = fs.readFileSync(path.join(dir, 'Cargo.toml'), 'utf-8');
        if (content.includes('sqlx') || content.includes('diesel')) details.databases.push('PostgreSQL');
        if (content.includes('mongodb')) details.databases.push('MongoDB');
      } catch (e) {}
    }

    // Java / Kotlin
    if (fs.existsSync(path.join(dir, 'build.gradle')) || fs.existsSync(path.join(dir, 'build.gradle.kts'))) {
      try {
        const gradleFile = fs.existsSync(path.join(dir, 'build.gradle.kts'))
          ? path.join(dir, 'build.gradle.kts')
          : path.join(dir, 'build.gradle');
        const content = fs.readFileSync(gradleFile, 'utf-8');
        if (content.includes('com.android')) detected.push({ type: 'kotlin-android', path: prefix });
        else if (content.includes('kotlin')) detected.push({ type: 'kotlin', path: prefix });
        else if (content.includes('spring')) detected.push({ type: 'java-spring', path: prefix });
        else detected.push({ type: 'java', path: prefix });

        if (content.includes('postgresql')) details.databases.push('PostgreSQL');
        if (content.includes('mysql')) details.databases.push('MySQL');
        if (content.includes('jpa') || content.includes('hibernate')) details.databases.push('JPA/Hibernate');
      } catch (e) {}
    } else if (fs.existsSync(path.join(dir, 'pom.xml'))) {
      try {
        const content = fs.readFileSync(path.join(dir, 'pom.xml'), 'utf-8');
        if (content.includes('spring')) detected.push({ type: 'java-spring', path: prefix });
        else detected.push({ type: 'java', path: prefix });

        if (content.includes('postgresql')) details.databases.push('PostgreSQL');
        if (content.includes('mysql')) details.databases.push('MySQL');
      } catch (e) {}
    }

    // Swift / iOS
    if (fs.existsSync(path.join(dir, 'Package.swift')) ||
        fs.readdirSync(dir).some(f => f.endsWith('.xcodeproj') || f.endsWith('.xcworkspace'))) {
      detected.push({ type: 'swift-ios', path: prefix });
    }

    return detected;
  };

  // CI/CD ê°ì§€
  if (fs.existsSync(path.join(projectRoot, '.github', 'workflows'))) {
    details.cicd.push('GitHub Actions');
  }
  if (fs.existsSync(path.join(projectRoot, '.gitlab-ci.yml'))) {
    details.cicd.push('GitLab CI');
  }
  if (fs.existsSync(path.join(projectRoot, 'Jenkinsfile'))) {
    details.cicd.push('Jenkins');
  }
  if (fs.existsSync(path.join(projectRoot, '.circleci'))) {
    details.cicd.push('CircleCI');
  }

  // Hosting ê°ì§€ (ì„¤ì • íŒŒì¼ ê¸°ë°˜)
  if (fs.existsSync(path.join(projectRoot, 'vercel.json')) ||
      fs.existsSync(path.join(projectRoot, '.vercel'))) {
    details.hosting.push('Vercel');
  }
  if (fs.existsSync(path.join(projectRoot, 'netlify.toml'))) {
    details.hosting.push('Netlify');
  }
  if (fs.existsSync(path.join(projectRoot, 'app.yaml')) ||
      fs.existsSync(path.join(projectRoot, 'cloudbuild.yaml'))) {
    details.hosting.push('Google Cloud');
  }
  if (fs.existsSync(path.join(projectRoot, 'Dockerfile')) ||
      fs.existsSync(path.join(projectRoot, 'docker-compose.yml'))) {
    details.hosting.push('Docker');
  }
  if (fs.existsSync(path.join(projectRoot, 'fly.toml'))) {
    details.hosting.push('Fly.io');
  }
  if (fs.existsSync(path.join(projectRoot, 'railway.json'))) {
    details.hosting.push('Railway');
  }

  // ë£¨íŠ¸ ë””ë ‰í† ë¦¬ ê²€ì‚¬
  stacks.push(...detectInDir(projectRoot));

  // 1ë ˆë²¨ í•˜ìœ„ í´ë” ê²€ì‚¬ (ì¼ë°˜ì ì¸ ëª¨ë…¸ë ˆí¬ êµ¬ì¡°)
  const subDirs = ['backend', 'frontend', 'server', 'client', 'api', 'web', 'mobile', 'app', 'packages', 'apps'];
  for (const subDir of subDirs) {
    const subPath = path.join(projectRoot, subDir);
    if (fs.existsSync(subPath) && fs.statSync(subPath).isDirectory()) {
      stacks.push(...detectInDir(subPath, subDir));
    }
  }

  // packages/* ë˜ëŠ” apps/* ë‚´ë¶€ ê²€ì‚¬ (monorepo)
  for (const monoDir of ['packages', 'apps']) {
    const monoPath = path.join(projectRoot, monoDir);
    if (fs.existsSync(monoPath) && fs.statSync(monoPath).isDirectory()) {
      const subPackages = fs.readdirSync(monoPath).filter(f => {
        const fullPath = path.join(monoPath, f);
        return fs.statSync(fullPath).isDirectory() && !f.startsWith('.');
      });
      for (const pkg of subPackages) {
        stacks.push(...detectInDir(path.join(monoPath, pkg), `${monoDir}/${pkg}`));
      }
    }
  }

  // ì¤‘ë³µ ì œê±°
  details.databases = [...new Set(details.databases)];
  details.stateManagement = [...new Set(details.stateManagement)];
  details.hosting = [...new Set(details.hosting)];
  details.cicd = [...new Set(details.cicd)];

  return { stacks, details };
}

// í˜‘ì—…ì ìë™ ì„¤ì¹˜ ì„¤ì •
function setupCollaboratorAutoInstall(projectRoot) {
  const packageJsonPath = path.join(projectRoot, 'package.json');
  const vibeDir = path.join(projectRoot, '.vibe');
  const packageJson = require('../package.json');
  const vibeVersion = packageJson.version;

  // 1. Node.js í”„ë¡œì íŠ¸: package.jsonì— devDependency + postinstall ì¶”ê°€
  if (fs.existsSync(packageJsonPath)) {
    try {
      const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));

      let modified = false;

      // ê¸°ì¡´ devDependenciesì—ì„œ @su-record/vibe ì œê±° (npm install ë¸”ë¡œí‚¹ ì›ì¸)
      if (pkg.devDependencies && pkg.devDependencies['@su-record/vibe']) {
        delete pkg.devDependencies['@su-record/vibe'];
        modified = true;
      }

      // ê¸°ì¡´ postinstall/prepareì—ì„œ vibe update ì œê±° (ë ˆê±°ì‹œ ì •ë¦¬)
      if (pkg.scripts) {
        const oldPatterns = [
          /\s*&&\s*npx @su-record\/vibe update[^&|;]*/g,
          /npx @su-record\/vibe update[^&|;]*\s*&&\s*/g,
          /npx @su-record\/vibe update[^&|;]*/g,
          /\s*&&\s*node_modules\/\.bin\/vibe update[^&|;]*/g,
          /node_modules\/\.bin\/vibe update[^&|;]*\s*&&\s*/g,
          /node_modules\/\.bin\/vibe update[^&|;]*/g
        ];

        ['postinstall', 'prepare'].forEach(script => {
          if (pkg.scripts[script] && pkg.scripts[script].includes('vibe update')) {
            let cleaned = pkg.scripts[script];
            oldPatterns.forEach(p => { cleaned = cleaned.replace(p, ''); });
            cleaned = cleaned.trim();
            if (cleaned) {
              pkg.scripts[script] = cleaned;
            } else {
              delete pkg.scripts[script];
            }
            modified = true;
          }
        });
      }

      if (modified) {
        fs.writeFileSync(packageJsonPath, JSON.stringify(pkg, null, 2) + '\n');
        log('   âœ… package.json ì •ë¦¬ ì™„ë£Œ (ë ˆê±°ì‹œ vibe ì„¤ì • ì œê±°)\n');
      }
    } catch (e) {
      log('   âš ï¸  package.json ìˆ˜ì • ì‹¤íŒ¨: ' + e.message + '\n');
    }
  }

  // 2. ë²”ìš©: .vibe/setup.sh ìƒì„± (ë¹„-Node í”„ë¡œì íŠ¸ ë˜ëŠ” ì¶”ê°€ ì§€ì›)
  const setupShPath = path.join(vibeDir, 'setup.sh');
  if (!fs.existsSync(setupShPath)) {
    const setupScript = `#!/bin/bash
# Vibe í˜‘ì—…ì ìë™ ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸
# ì‚¬ìš©ë²•: ./.vibe/setup.sh

set -e

echo "ğŸ”§ Vibe ì„¤ì¹˜ í™•ì¸ ì¤‘..."

# npm/npx í™•ì¸
if ! command -v npx &> /dev/null; then
    echo "âŒ Node.js/npmì´ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤."
    echo "   https://nodejs.org ì—ì„œ ì„¤ì¹˜í•´ì£¼ì„¸ìš”."
    exit 1
fi

# vibe ì„¤ì¹˜ í™•ì¸ ë° ì—…ë°ì´íŠ¸
if command -v vibe &> /dev/null; then
    echo "âœ… Vibeê°€ ì´ë¯¸ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤."
    vibe update --silent
    echo "âœ… Vibe ì—…ë°ì´íŠ¸ ì™„ë£Œ!"
else
    echo "ğŸ“¦ Vibe ì„¤ì¹˜ ì¤‘..."
    npm install -g @su-record/vibe
    vibe update --silent
    echo "âœ… Vibe ì„¤ì¹˜ ë° ì„¤ì • ì™„ë£Œ!"
fi

echo ""
echo "ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì‹œì‘í•˜ì„¸ìš”:"
echo "  /vibe.spec \\"ê¸°ëŠ¥ëª…\\"    SPEC ì‘ì„±"
echo "  /vibe.run \\"ê¸°ëŠ¥ëª…\\"     êµ¬í˜„ ì‹¤í–‰"
`;
    fs.writeFileSync(setupShPath, setupScript);
    fs.chmodSync(setupShPath, '755');
    log('   âœ… í˜‘ì—…ì ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸ ìƒì„± (.vibe/setup.sh)\n');
  }

  // 3. README.mdì— í˜‘ì—…ì ì•ˆë‚´ ì¶”ê°€
  const readmePath = path.join(projectRoot, 'README.md');
  const vibeSetupSection = `
## Vibe Setup (AI Coding)

ì´ í”„ë¡œì íŠ¸ëŠ” [Vibe](https://github.com/su-record/vibe) AI ì½”ë”© í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

### í˜‘ì—…ì ì„¤ì¹˜

\`\`\`bash
# ì „ì—­ ì„¤ì¹˜ (ê¶Œì¥)
npm install -g @su-record/vibe
vibe update

# ë˜ëŠ” setup ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
./.vibe/setup.sh
\`\`\`

### ì‚¬ìš©ë²•

Claude Codeì—ì„œ ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ì‚¬ìš©:
- \`/vibe.spec "ê¸°ëŠ¥ëª…"\` - SPEC ë¬¸ì„œ ì‘ì„±
- \`/vibe.run "ê¸°ëŠ¥ëª…"\` - êµ¬í˜„ ì‹¤í–‰
`;

  if (fs.existsSync(readmePath)) {
    const readme = fs.readFileSync(readmePath, 'utf-8');
    if (!readme.includes('## Vibe Setup')) {
      fs.appendFileSync(readmePath, vibeSetupSection);
      log('   âœ… README.mdì— í˜‘ì—…ì ì•ˆë‚´ ì¶”ê°€\n');
    }
  } else {
    // READMEê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
    fs.writeFileSync(readmePath, `# Project\n${vibeSetupSection}`);
    log('   âœ… README.md ìƒì„± (í˜‘ì—…ì ì•ˆë‚´ í¬í•¨)\n');
  }
}

// í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
async function init(projectName) {
  try {
    let projectRoot = process.cwd();
    let isNewProject = false;

    if (projectName) {
      projectRoot = path.join(process.cwd(), projectName);

      if (fs.existsSync(projectRoot)) {
        log(`âŒ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤: ${projectName}/`);
        return;
      }

      log(`ğŸ“ ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±: ${projectName}/\n`);
      fs.mkdirSync(projectRoot, { recursive: true });
      isNewProject = true;
    }

    const vibeDir = path.join(projectRoot, '.vibe');
    if (fs.existsSync(vibeDir)) {
      log('âŒ .vibe/ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.');
      return;
    }

    // .vibe í´ë” ë¨¼ì € ìƒì„±
    ensureDir(vibeDir);

    // MCP ì„œë²„ ë“±ë¡ (Claude Code)
    log('ğŸ”§ Claude Code MCP ì„œë²„ ë“±ë¡ ì¤‘ (ì „ì—­)...\n');
    const { execSync } = require('child_process');

    // ì „ì—­ vibe ê²½ë¡œì—ì„œ hi-ai MCP ë“±ë¡
    const vibePath = path.dirname(__dirname);
    const hiAiPath = path.join(vibePath, 'node_modules', '@su-record', 'hi-ai', 'dist', 'index.js');
    const geminiMcpPath = path.join(vibePath, 'lib', 'gemini-mcp.js');

    // 1. hi-ai MCP (ì „ì—­ ë“±ë¡)
    try {
      execSync(`claude mcp add vibe -s user node "${hiAiPath}"`, { stdio: 'pipe' });
      log('   âœ… vibe MCP ë“±ë¡ ì™„ë£Œ (ì „ì—­)\n');
    } catch (e) {
      if (e.message.includes('already exists')) {
        log('   â„¹ï¸  vibe MCP ì´ë¯¸ ë“±ë¡ë¨\n');
      } else {
        log('   âš ï¸  vibe MCP ìˆ˜ë™ ë“±ë¡ í•„ìš”: claude mcp add vibe -s user node "' + hiAiPath + '"\n');
      }
    }

    // 2. Context7 MCP (ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ ê²€ìƒ‰, ì „ì—­)
    try {
      execSync('claude mcp add context7 -s user -- npx -y @upstash/context7-mcp@latest', { stdio: 'pipe' });
      log('   âœ… Context7 MCP ë“±ë¡ ì™„ë£Œ (ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ ê²€ìƒ‰)\n');
    } catch (e) {
      if (e.message.includes('already exists')) {
        log('   â„¹ï¸  Context7 MCP ì´ë¯¸ ë“±ë¡ë¨\n');
      } else {
        log('   âš ï¸  Context7 MCP ìˆ˜ë™ ë“±ë¡ í•„ìš”: claude mcp add context7 -s user -- npx -y @upstash/context7-mcp@latest\n');
      }
    }

    // .vibe í´ë” êµ¬ì¡° ìƒì„±
    const dirs = ['specs', 'features'];
    dirs.forEach(dir => {
      ensureDir(path.join(vibeDir, dir));
    });

    // ê¸°ì¡´ .vibe/mcp/ í´ë” ì •ë¦¬ (ë§ˆì´ê·¸ë ˆì´ì…˜)
    const oldMcpDir = path.join(vibeDir, 'mcp');
    if (fs.existsSync(oldMcpDir)) {
      log('   ğŸ§¹ ê¸°ì¡´ .vibe/mcp/ í´ë” ì •ë¦¬ ì¤‘...\n');
      try {
        removeDirRecursive(oldMcpDir);
        log('   âœ… .vibe/mcp/ í´ë” ì‚­ì œ ì™„ë£Œ (ì „ì—­ MCPë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜)\n');
      } catch (e) {
        log('   âš ï¸  .vibe/mcp/ í´ë” ìˆ˜ë™ ì‚­ì œ í•„ìš”\n');
      }
    }

    // .gitignore ì—…ë°ì´íŠ¸ (mcp ì œê±°)
    const mcpGitignorePath = path.join(projectRoot, '.gitignore');
    const mcpIgnore = '.vibe/mcp/';
    if (fs.existsSync(mcpGitignorePath)) {
      let mcpGitignore = fs.readFileSync(mcpGitignorePath, 'utf-8');
      if (!mcpGitignore.includes(mcpIgnore)) {
        mcpGitignore += `\n# vibe MCP\n${mcpIgnore}\n`;
        fs.writeFileSync(mcpGitignorePath, mcpGitignore);
      }
    } else {
      fs.writeFileSync(mcpGitignorePath, `# vibe MCP\n${mcpIgnore}\n`);
    }

    // .claude/commands ë³µì‚¬
    const claudeDir = path.join(projectRoot, '.claude');
    const commandsDir = path.join(claudeDir, 'commands');
    ensureDir(claudeDir);
    ensureDir(commandsDir);

    const sourceDir = path.join(__dirname, '../.claude/commands');
    copyDirContents(sourceDir, commandsDir);
    log('   âœ… ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ì„¤ì¹˜ ì™„ë£Œ (7ê°œ)\n');

    // ê¸°ìˆ  ìŠ¤íƒ ê°ì§€ (ì‹¤ì œ ì˜ì¡´ì„± ê¸°ë°˜)
    const { stacks: detectedStacks, details: stackDetails } = detectTechStacks(projectRoot);
    if (detectedStacks.length > 0) {
      log(`   ğŸ” ê°ì§€ëœ ê¸°ìˆ  ìŠ¤íƒ:\n`);
      detectedStacks.forEach(s => {
        log(`      - ${s.type}${s.path ? ` (${s.path}/)` : ''}\n`);
      });
      if (stackDetails.databases.length > 0) {
        log(`      - DB: ${stackDetails.databases.join(', ')}\n`);
      }
      if (stackDetails.stateManagement.length > 0) {
        log(`      - State: ${stackDetails.stateManagement.join(', ')}\n`);
      }
    }

    // constitution.md ìƒì„± (ì‹¤ì œ ê°ì§€ëœ ìŠ¤íƒìœ¼ë¡œ í”Œë ˆì´ìŠ¤í™€ë” ì—…ë°ì´íŠ¸)
    const templatePath = path.join(__dirname, '../templates/constitution-template.md');
    const constitutionPath = path.join(vibeDir, 'constitution.md');
    if (fs.existsSync(templatePath)) {
      let constitution = fs.readFileSync(templatePath, 'utf-8');

      // ê¸°ìˆ  ìŠ¤íƒ ì •ë³´ ìƒì„±
      const backendStack = detectedStacks.find(s =>
        s.type.includes('python') || s.type.includes('node') ||
        s.type.includes('go') || s.type.includes('java') || s.type.includes('rust')
      );
      const frontendStack = detectedStacks.find(s =>
        s.type.includes('react') || s.type.includes('vue') ||
        s.type.includes('flutter') || s.type.includes('swift') || s.type.includes('android')
      );

      // ìŠ¤íƒ ì´ë¦„ ë§¤í•‘ (ê¸°ë³¸ê°’)
      const stackNames = {
        'python-fastapi': { lang: 'Python 3.11+', framework: 'FastAPI' },
        'python-django': { lang: 'Python 3.11+', framework: 'Django' },
        'python': { lang: 'Python 3.11+', framework: '-' },
        'typescript-node': { lang: 'TypeScript/Node.js', framework: 'Express/Fastify' },
        'typescript-nextjs': { lang: 'TypeScript', framework: 'Next.js' },
        'typescript-react': { lang: 'TypeScript', framework: 'React' },
        'typescript-vue': { lang: 'TypeScript', framework: 'Vue.js' },
        'typescript-react-native': { lang: 'TypeScript', framework: 'React Native' },
        'dart-flutter': { lang: 'Dart', framework: 'Flutter' },
        'go': { lang: 'Go', framework: '-' },
        'rust': { lang: 'Rust', framework: '-' },
        'java-spring': { lang: 'Java 17+', framework: 'Spring Boot' },
        'kotlin-android': { lang: 'Kotlin', framework: 'Android' },
        'swift-ios': { lang: 'Swift', framework: 'iOS/SwiftUI' }
      };

      // í”Œë ˆì´ìŠ¤í™€ë” ì—…ë°ì´íŠ¸ - Backend
      if (backendStack && stackNames[backendStack.type]) {
        const info = stackNames[backendStack.type];
        constitution = constitution.replace(
          '- Language: {Python 3.11+ / Node.js / etc.}',
          `- Language: ${info.lang}`
        );
        constitution = constitution.replace(
          '- Framework: {FastAPI / Express / etc.}',
          `- Framework: ${info.framework}`
        );
      }

      // í”Œë ˆì´ìŠ¤í™€ë” ì—…ë°ì´íŠ¸ - Frontend
      if (frontendStack && stackNames[frontendStack.type]) {
        const info = stackNames[frontendStack.type];
        constitution = constitution.replace(
          '- Framework: {Flutter / React / etc.}',
          `- Framework: ${info.framework}`
        );
      }

      // ì‹¤ì œ ê°ì§€ëœ DBë¡œ í”Œë ˆì´ìŠ¤í™€ë” ì—…ë°ì´íŠ¸
      if (stackDetails.databases.length > 0) {
        constitution = constitution.replace(
          '- Database: {PostgreSQL / MongoDB / etc.}',
          `- Database: ${stackDetails.databases.join(', ')}`
        );
      } else {
        constitution = constitution.replace(
          '- Database: {PostgreSQL / MongoDB / etc.}',
          '- Database: (í”„ë¡œì íŠ¸ì— ë§ê²Œ ì„¤ì •)'
        );
      }

      // ì‹¤ì œ ê°ì§€ëœ ìƒíƒœê´€ë¦¬ë¡œ í”Œë ˆì´ìŠ¤í™€ë” ì—…ë°ì´íŠ¸
      if (stackDetails.stateManagement.length > 0) {
        constitution = constitution.replace(
          '- State Management: {Provider / Redux / etc.}',
          `- State Management: ${stackDetails.stateManagement.join(', ')}`
        );
      } else {
        constitution = constitution.replace(
          '- State Management: {Provider / Redux / etc.}',
          '- State Management: (í”„ë¡œì íŠ¸ì— ë§ê²Œ ì„¤ì •)'
        );
      }

      // ì‹¤ì œ ê°ì§€ëœ Hostingìœ¼ë¡œ í”Œë ˆì´ìŠ¤í™€ë” ì—…ë°ì´íŠ¸
      if (stackDetails.hosting.length > 0) {
        constitution = constitution.replace(
          '- Hosting: {Cloud Run / Vercel / etc.}',
          `- Hosting: ${stackDetails.hosting.join(', ')}`
        );
      } else {
        constitution = constitution.replace(
          '- Hosting: {Cloud Run / Vercel / etc.}',
          '- Hosting: (í”„ë¡œì íŠ¸ì— ë§ê²Œ ì„¤ì •)'
        );
      }

      // ì‹¤ì œ ê°ì§€ëœ CI/CDë¡œ í”Œë ˆì´ìŠ¤í™€ë” ì—…ë°ì´íŠ¸
      if (stackDetails.cicd.length > 0) {
        constitution = constitution.replace(
          '- CI/CD: {GitHub Actions / etc.}',
          `- CI/CD: ${stackDetails.cicd.join(', ')}`
        );
      } else {
        constitution = constitution.replace(
          '- CI/CD: {GitHub Actions / etc.}',
          '- CI/CD: (í”„ë¡œì íŠ¸ì— ë§ê²Œ ì„¤ì •)'
        );
      }

      fs.writeFileSync(constitutionPath, constitution);
    }

    const config = {
      language: 'ko',
      quality: { strict: true, autoVerify: true },
      stacks: detectedStacks,
      details: stackDetails
    };
    fs.writeFileSync(path.join(vibeDir, 'config.json'), JSON.stringify(config, null, 2));

    // CLAUDE.md ë³‘í•© (ê¸°ì¡´ ë‚´ìš© ë³´ì¡´)
    const vibeClaudeMd = path.join(__dirname, '../CLAUDE.md');
    const projectClaudeMd = path.join(projectRoot, 'CLAUDE.md');

    if (fs.existsSync(projectClaudeMd)) {
      // ê¸°ì¡´ CLAUDE.mdê°€ ìˆìœ¼ë©´ vibe ì„¹ì…˜ ì¶”ê°€
      const existingContent = fs.readFileSync(projectClaudeMd, 'utf-8');
      const vibeContent = fs.readFileSync(vibeClaudeMd, 'utf-8');

      if (!existingContent.includes('/vibe.spec')) {
        // vibe ì„¹ì…˜ì´ ì—†ìœ¼ë©´ ëì— ì¶”ê°€
        const mergedContent = existingContent.trim() + '\n\n---\n\n' + vibeContent;
        fs.writeFileSync(projectClaudeMd, mergedContent);
        log('   âœ… CLAUDE.mdì— vibe ì„¹ì…˜ ì¶”ê°€\n');
      } else {
        log('   â„¹ï¸  CLAUDE.mdì— vibe ì„¹ì…˜ ì´ë¯¸ ì¡´ì¬\n');
      }
    } else {
      // ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
      fs.copyFileSync(vibeClaudeMd, projectClaudeMd);
      log('   âœ… CLAUDE.md ìƒì„±\n');
    }

    // .vibe/rules/ ë³µì‚¬ (ê°ì§€ëœ ìŠ¤íƒì— í•´ë‹¹í•˜ëŠ” ì–¸ì–´ ê·œì¹™ë§Œ)
    const rulesSource = path.join(__dirname, '../.vibe/rules');
    const rulesTarget = path.join(vibeDir, 'rules');

    // core, quality, standards, toolsëŠ” ì „ì²´ ë³µì‚¬
    const coreDirs = ['core', 'quality', 'standards', 'tools'];
    coreDirs.forEach(dir => {
      const src = path.join(rulesSource, dir);
      const dst = path.join(rulesTarget, dir);
      if (fs.existsSync(src)) {
        copyDirRecursive(src, dst);
      }
    });

    // languagesëŠ” ê°ì§€ëœ ìŠ¤íƒë§Œ ë³µì‚¬
    const langSource = path.join(rulesSource, 'languages');
    const langTarget = path.join(rulesTarget, 'languages');
    ensureDir(langTarget);

    const detectedTypes = detectedStacks.map(s => s.type);
    if (fs.existsSync(langSource)) {
      const langFiles = fs.readdirSync(langSource);
      langFiles.forEach(file => {
        const langType = file.replace('.md', '');
        // ê°ì§€ëœ ìŠ¤íƒì— í•´ë‹¹í•˜ëŠ” íŒŒì¼ë§Œ ë³µì‚¬
        if (detectedTypes.includes(langType)) {
          fs.copyFileSync(path.join(langSource, file), path.join(langTarget, file));
        }
      });
    }

    const copiedLangs = detectedTypes.filter(t =>
      fs.existsSync(path.join(langTarget, `${t}.md`))
    );
    log('   âœ… ì½”ë”© ê·œì¹™ ì„¤ì¹˜ ì™„ë£Œ (.vibe/rules/)\n');

    // .claude/agents/ ë³µì‚¬ (ì„œë¸Œì—ì´ì „íŠ¸)
    const agentsDir = path.join(claudeDir, 'agents');
    ensureDir(agentsDir);
    const agentsSourceDir = path.join(__dirname, '../.claude/agents');
    copyDirContents(agentsSourceDir, agentsDir);
    log('   âœ… ì„œë¸Œì—ì´ì „íŠ¸ ì„¤ì¹˜ ì™„ë£Œ (.claude/agents/)\n');

    // .claude/settings.json ìƒì„±/ì—…ë°ì´íŠ¸ (Hooks ì„¤ì • - ì €ì¥ì†Œ ê³µìœ ìš©)
    const settingsPath = path.join(claudeDir, 'settings.json');
    const hooksTemplate = path.join(__dirname, '../templates/hooks-template.json');
    if (fs.existsSync(hooksTemplate)) {
      const vibeHooks = JSON.parse(fs.readFileSync(hooksTemplate, 'utf-8'));
      if (fs.existsSync(settingsPath)) {
        // ê¸°ì¡´ ì„¤ì •ì— hooks ë³‘í•©
        const existingSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
        existingSettings.hooks = vibeHooks.hooks;
        fs.writeFileSync(settingsPath, JSON.stringify(existingSettings, null, 2));
        log('   âœ… Hooks ì„¤ì • ì—…ë°ì´íŠ¸ ì™„ë£Œ (.claude/settings.json)\n');
      } else {
        // ìƒˆë¡œ ìƒì„±
        fs.copyFileSync(hooksTemplate, settingsPath);
        log('   âœ… Hooks ì„¤ì • ì„¤ì¹˜ ì™„ë£Œ (.claude/settings.json)\n');
      }
    }

    // .gitignoreì—ì„œ settings.local.json ì œê±° (ì €ì¥ì†Œ ê³µìœ  í•„ìš”)
    const gitignorePath = path.join(projectRoot, '.gitignore');
    if (fs.existsSync(gitignorePath)) {
      let gitignore = fs.readFileSync(gitignorePath, 'utf-8');
      if (gitignore.includes('settings.local.json')) {
        gitignore = gitignore.replace(/\.claude\/settings\.local\.json\n?/g, '');
        gitignore = gitignore.replace(/settings\.local\.json\n?/g, '');
        fs.writeFileSync(gitignorePath, gitignore);
        log('   âœ… .gitignoreì—ì„œ settings.local.json ì œê±° (ì €ì¥ì†Œ ê³µìœ )\n');
      }
    }

    // í˜‘ì—…ì ìë™ ì„¤ì¹˜ ì„¤ì •
    setupCollaboratorAutoInstall(projectRoot);

    // ì™„ë£Œ ë©”ì‹œì§€
    log(`
âœ… vibe ì´ˆê¸°í™” ì™„ë£Œ!

${isNewProject ? `í”„ë¡œì íŠ¸ ìœ„ì¹˜:
  ${projectRoot}/

` : ''}ìƒì„±ëœ êµ¬ì¡°:
  CLAUDE.md                      # í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸
  .claude/
  â”œâ”€â”€ commands/                  # ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (7ê°œ)
  â”œâ”€â”€ agents/                    # ì„œë¸Œì—ì´ì „íŠ¸ (simplifier)
  â””â”€â”€ settings.json              # Hooks ì„¤ì • (ì €ì¥ì†Œ ê³µìœ )
  .vibe/
  â”œâ”€â”€ config.json                # í”„ë¡œì íŠ¸ ì„¤ì •
  â”œâ”€â”€ constitution.md            # í”„ë¡œì íŠ¸ ì›ì¹™
  â”œâ”€â”€ setup.sh                   # í˜‘ì—…ì ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸
  â”œâ”€â”€ rules/                     # ì½”ë”© ê·œì¹™
  â”‚   â”œâ”€â”€ core/                  # í•µì‹¬ ì›ì¹™
  â”‚   â”œâ”€â”€ quality/               # í’ˆì§ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸
  â”‚   â””â”€â”€ languages/             # ì–¸ì–´ë³„ ê·œì¹™
  â”œâ”€â”€ specs/                     # SPEC ë¬¸ì„œë“¤
  â””â”€â”€ features/                  # BDD Feature íŒŒì¼ë“¤

MCP ì„œë²„ (hi-ai): âœ“
í˜‘ì—…ì ìë™ ì„¤ì¹˜: âœ“

ì‚¬ìš©ë²•:
  /vibe.spec "ê¸°ëŠ¥ëª…"            SPEC ì‘ì„± (ëŒ€í™”í˜•)
  /vibe.run "ê¸°ëŠ¥ëª…"             êµ¬í˜„ ì‹¤í–‰
  /vibe.verify "ê¸°ëŠ¥ëª…"          ê²€ì¦

ë‹¤ìŒ ë‹¨ê³„:
  ${isNewProject ? `cd ${projectName}\n  ` : ''}/vibe.spec "ê¸°ëŠ¥ëª…" ìœ¼ë¡œ ì‹œì‘í•˜ì„¸ìš”!
    `);

  } catch (error) {
    console.error('âŒ ì´ˆê¸°í™” ì‹¤íŒ¨:', error.message);
    process.exit(1);
  }
}

// ë„ì›€ë§ ì¶œë ¥
function showHelp() {
  console.log(`
ğŸ“– Vibe - SPEC-driven AI coding framework (Claude Code ì „ìš©)

ê¸°ë³¸ ëª…ë ¹ì–´:
  vibe init [project]     í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
  vibe update             ì„¤ì • ì—…ë°ì´íŠ¸
  vibe remove             vibe ì œê±° (MCP, ì„¤ì •, íŒ¨í‚¤ì§€)
  vibe status             í˜„ì¬ ì„¤ì • ìƒíƒœ
  vibe help               ë„ì›€ë§
  vibe version            ë²„ì „ ì •ë³´

ì™¸ë¶€ LLM (ì„ íƒì ):
  vibe gpt <api-key>      GPT í™œì„±í™” (ì•„í‚¤í…ì²˜/ë””ë²„ê¹…)
  vibe gemini --auth      Gemini êµ¬ë… ì¸ì¦ (ì¶”ê°€ ë¹„ìš© ì—†ìŒ, ê¶Œì¥)
  vibe gemini <api-key>   Gemini API í‚¤ ì„¤ì • (ì‚¬ìš©ëŸ‰ ê³¼ê¸ˆ)
  vibe gemini --status    Gemini ì¸ì¦ ìƒíƒœ í™•ì¸
  vibe gemini --logout    Gemini ë¡œê·¸ì•„ì›ƒ
  vibe gpt --remove       GPT ë¹„í™œì„±í™”
  vibe gemini --remove    Gemini API í‚¤ ì œê±°

Claude Code ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ:
  /vibe.spec "ê¸°ëŠ¥ëª…"     SPEC ì‘ì„± (PTCF êµ¬ì¡°)
  /vibe.run "ê¸°ëŠ¥ëª…"      êµ¬í˜„ ì‹¤í–‰
  /vibe.verify "ê¸°ëŠ¥ëª…"   ê²€ì¦
  /vibe.reason "ë¬¸ì œ"     ì²´ê³„ì  ì¶”ë¡ 
  /vibe.analyze           í”„ë¡œì íŠ¸ ë¶„ì„
  /vibe.ui "ì„¤ëª…"         UI ë¯¸ë¦¬ë³´ê¸°
  /vibe.diagram           ë‹¤ì´ì–´ê·¸ë¨ ìƒì„±

ëª¨ë¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜:
  Opus 4.5    ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° (ë©”ì¸)
  Sonnet 4    êµ¬í˜„
  Haiku 4.5   ì½”ë“œ íƒìƒ‰
  GPT 5.2     ì•„í‚¤í…ì²˜/ë””ë²„ê¹… (ì„ íƒì )
  Gemini 3    UI/UX ì„¤ê³„ (ì„ íƒì )

Workflow:
  /vibe.spec â†’ /vibe.run â†’ /vibe.verify

ë¬¸ì„œ:
  https://github.com/su-record/vibe
  `);
}

// ë””ë ‰í† ë¦¬ ì‚­ì œ (ì¬ê·€)
function removeDirRecursive(dirPath) {
  if (!fs.existsSync(dirPath)) return;

  fs.readdirSync(dirPath).forEach(item => {
    const itemPath = path.join(dirPath, item);
    if (fs.statSync(itemPath).isDirectory()) {
      removeDirRecursive(itemPath);
    } else {
      fs.unlinkSync(itemPath);
    }
  });
  fs.rmdirSync(dirPath);
}

// ìµœì‹  ë²„ì „ í™•ì¸ ë° ìë™ ì—…ê·¸ë ˆì´ë“œ
async function checkAndUpgradeVibe() {
  const { execSync } = require('child_process');
  const currentVersion = require('../package.json').version;

  try {
    // npmì—ì„œ ìµœì‹  ë²„ì „ í™•ì¸
    const latestVersion = execSync('npm view @su-record/vibe version', {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();

    if (latestVersion !== currentVersion) {
      log(`   ğŸ“¦ ìƒˆ ë²„ì „ ë°œê²¬: v${currentVersion} â†’ v${latestVersion}\n`);
      log('   â¬†ï¸  vibe ì—…ê·¸ë ˆì´ë“œ ì¤‘...\n');

      execSync('npm install -g @su-record/vibe@latest', {
        stdio: options.silent ? 'pipe' : 'inherit'
      });

      log('   âœ… vibe ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ!\n');

      // ì—…ê·¸ë ˆì´ë“œ í›„ ìƒˆ ë²„ì „ìœ¼ë¡œ update ì¬ì‹¤í–‰
      log('   ğŸ”„ ìƒˆ ë²„ì „ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ì¬ì‹¤í–‰...\n\n');
      execSync(`vibe update${options.silent ? ' --silent' : ''}`, {
        stdio: 'inherit',
        cwd: process.cwd()
      });
      return true; // ì¬ì‹¤í–‰ë¨
    } else {
      log(`   âœ… ìµœì‹  ë²„ì „ ì‚¬ìš© ì¤‘ (v${currentVersion})\n`);
      return false; // ê³„ì† ì§„í–‰
    }
  } catch (e) {
    // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë“±ì€ ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
    log(`   â„¹ï¸  ë²„ì „ í™•ì¸ ìŠ¤í‚µ (ì˜¤í”„ë¼ì¸ ë˜ëŠ” ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜)\n`);
    return false;
  }
}

// í”„ë¡œì íŠ¸ ì—…ë°ì´íŠ¸
async function update() {
  try {
    const projectRoot = process.cwd();
    const vibeDir = path.join(projectRoot, '.vibe');
    const claudeDir = path.join(projectRoot, '.claude');

    // CI/í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” ìŠ¤í‚µ (NODE_ENV=production ë˜ëŠ” CI=true)
    if (process.env.NODE_ENV === 'production' || process.env.CI === 'true') {
      return;
    }

    if (!fs.existsSync(vibeDir)) {
      // silent ëª¨ë“œì—ì„œëŠ” ì—ëŸ¬ ì¶œë ¥í•˜ì§€ ì•ŠìŒ
      if (!options.silent) {
        console.log('âŒ vibe í”„ë¡œì íŠ¸ê°€ ì•„ë‹™ë‹ˆë‹¤. ë¨¼ì € vibe initì„ ì‹¤í–‰í•˜ì„¸ìš”.');
      }
      return;
    }

    log('ğŸ”„ vibe ì—…ë°ì´íŠ¸ ì¤‘...\n');

    // ìµœì‹  ë²„ì „ í™•ì¸ ë° ìë™ ì—…ê·¸ë ˆì´ë“œ (silent ëª¨ë“œì—ì„œëŠ” ìŠ¤í‚µ)
    if (!options.silent) {
      const wasUpgraded = await checkAndUpgradeVibe();
      if (wasUpgraded) {
        return; // ìƒˆ ë²„ì „ì—ì„œ ì¬ì‹¤í–‰ë¨
      }
    }

    // ë§ˆì´ê·¸ë ˆì´ì…˜: .agent/rules/ â†’ .vibe/rules/
    const oldRulesDir = path.join(projectRoot, '.agent/rules');
    const oldAgentDir = path.join(projectRoot, '.agent');
    if (fs.existsSync(oldRulesDir)) {
      log('   ğŸ”„ ë§ˆì´ê·¸ë ˆì´ì…˜: .agent/rules/ â†’ .vibe/rules/\n');
      removeDirRecursive(oldRulesDir);
      // .agent í´ë”ê°€ ë¹„ì–´ìˆìœ¼ë©´ ì‚­ì œ
      if (fs.existsSync(oldAgentDir) && fs.readdirSync(oldAgentDir).length === 0) {
        fs.rmdirSync(oldAgentDir);
      }
      log('   âœ… ê¸°ì¡´ .agent/rules/ í´ë” ì •ë¦¬ ì™„ë£Œ\n');
    }

    // .claude/commands ì—…ë°ì´íŠ¸
    const commandsDir = path.join(claudeDir, 'commands');
    ensureDir(commandsDir);
    const sourceDir = path.join(__dirname, '../.claude/commands');
    copyDirContents(sourceDir, commandsDir);
    log('   âœ… ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ì—…ë°ì´íŠ¸ ì™„ë£Œ (7ê°œ)\n');

    // ê¸°ìˆ  ìŠ¤íƒ ê°ì§€ (updateì—ì„œë„ ì‹¤ì œ ì˜ì¡´ì„± ê¸°ë°˜)
    const { stacks: detectedStacks, details: stackDetails } = detectTechStacks(projectRoot);

    // config.json ì—…ë°ì´íŠ¸ (stacks + details ì •ë³´ ì¶”ê°€)
    const configPath = path.join(vibeDir, 'config.json');
    if (fs.existsSync(configPath)) {
      try {
        const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
        config.stacks = detectedStacks;
        config.details = stackDetails;
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
      } catch (e) {}
    }

    // constitution.md ì—…ë°ì´íŠ¸ (ì‹¤ì œ ê°ì§€ëœ ìŠ¤íƒìœ¼ë¡œ)
    const templatePath = path.join(__dirname, '../templates/constitution-template.md');
    const constitutionPath = path.join(vibeDir, 'constitution.md');
    if (fs.existsSync(templatePath)) {
      let constitution = fs.readFileSync(templatePath, 'utf-8');

      const backendStack = detectedStacks.find(s =>
        s.type.includes('python') || s.type.includes('node') ||
        s.type.includes('go') || s.type.includes('java') || s.type.includes('rust')
      );
      const frontendStack = detectedStacks.find(s =>
        s.type.includes('react') || s.type.includes('vue') ||
        s.type.includes('flutter') || s.type.includes('swift') || s.type.includes('android')
      );

      const stackNames = {
        'python-fastapi': { lang: 'Python 3.11+', framework: 'FastAPI' },
        'python-django': { lang: 'Python 3.11+', framework: 'Django' },
        'python': { lang: 'Python 3.11+', framework: '-' },
        'typescript-node': { lang: 'TypeScript/Node.js', framework: 'Express/Fastify' },
        'typescript-nextjs': { lang: 'TypeScript', framework: 'Next.js' },
        'typescript-react': { lang: 'TypeScript', framework: 'React' },
        'typescript-vue': { lang: 'TypeScript', framework: 'Vue.js' },
        'typescript-react-native': { lang: 'TypeScript', framework: 'React Native' },
        'dart-flutter': { lang: 'Dart', framework: 'Flutter' },
        'go': { lang: 'Go', framework: '-' },
        'rust': { lang: 'Rust', framework: '-' },
        'java-spring': { lang: 'Java 17+', framework: 'Spring Boot' },
        'kotlin-android': { lang: 'Kotlin', framework: 'Android' },
        'swift-ios': { lang: 'Swift', framework: 'iOS/SwiftUI' }
      };

      if (backendStack && stackNames[backendStack.type]) {
        const info = stackNames[backendStack.type];
        constitution = constitution.replace('- Language: {Python 3.11+ / Node.js / etc.}', `- Language: ${info.lang}`);
        constitution = constitution.replace('- Framework: {FastAPI / Express / etc.}', `- Framework: ${info.framework}`);
      }

      if (frontendStack && stackNames[frontendStack.type]) {
        const info = stackNames[frontendStack.type];
        constitution = constitution.replace('- Framework: {Flutter / React / etc.}', `- Framework: ${info.framework}`);
      }

      // ì‹¤ì œ ê°ì§€ëœ ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸
      constitution = constitution.replace(
        '- Database: {PostgreSQL / MongoDB / etc.}',
        stackDetails.databases.length > 0 ? `- Database: ${stackDetails.databases.join(', ')}` : '- Database: (í”„ë¡œì íŠ¸ì— ë§ê²Œ ì„¤ì •)'
      );
      constitution = constitution.replace(
        '- State Management: {Provider / Redux / etc.}',
        stackDetails.stateManagement.length > 0 ? `- State Management: ${stackDetails.stateManagement.join(', ')}` : '- State Management: (í”„ë¡œì íŠ¸ì— ë§ê²Œ ì„¤ì •)'
      );
      constitution = constitution.replace(
        '- Hosting: {Cloud Run / Vercel / etc.}',
        stackDetails.hosting.length > 0 ? `- Hosting: ${stackDetails.hosting.join(', ')}` : '- Hosting: (í”„ë¡œì íŠ¸ì— ë§ê²Œ ì„¤ì •)'
      );
      constitution = constitution.replace(
        '- CI/CD: {GitHub Actions / etc.}',
        stackDetails.cicd.length > 0 ? `- CI/CD: ${stackDetails.cicd.join(', ')}` : '- CI/CD: (í”„ë¡œì íŠ¸ì— ë§ê²Œ ì„¤ì •)'
      );

      fs.writeFileSync(constitutionPath, constitution);
      log('   âœ… constitution.md ì—…ë°ì´íŠ¸ ì™„ë£Œ\n');
    }

    // .vibe/rules/ ì—…ë°ì´íŠ¸ (ê°ì§€ëœ ìŠ¤íƒì— í•´ë‹¹í•˜ëŠ” ì–¸ì–´ ê·œì¹™ë§Œ)
    const rulesSource = path.join(__dirname, '../.vibe/rules');
    const rulesTarget = path.join(vibeDir, 'rules');

    // core, quality, standards, toolsëŠ” ì „ì²´ ë³µì‚¬
    const coreDirs = ['core', 'quality', 'standards', 'tools'];
    coreDirs.forEach(dir => {
      const src = path.join(rulesSource, dir);
      const dst = path.join(rulesTarget, dir);
      if (fs.existsSync(src)) {
        copyDirRecursive(src, dst);
      }
    });

    // languagesëŠ” ê°ì§€ëœ ìŠ¤íƒë§Œ ë³µì‚¬ (ê¸°ì¡´ ë¶ˆí•„ìš” íŒŒì¼ ì œê±°)
    const langSource = path.join(rulesSource, 'languages');
    const langTarget = path.join(rulesTarget, 'languages');

    // ê¸°ì¡´ languages í´ë” ì •ë¦¬ í›„ í•„ìš”í•œ ê²ƒë§Œ ë³µì‚¬
    if (fs.existsSync(langTarget)) {
      removeDirRecursive(langTarget);
    }
    ensureDir(langTarget);

    const detectedTypes = detectedStacks.map(s => s.type);
    if (fs.existsSync(langSource)) {
      const langFiles = fs.readdirSync(langSource);
      langFiles.forEach(file => {
        const langType = file.replace('.md', '');
        if (detectedTypes.includes(langType)) {
          fs.copyFileSync(path.join(langSource, file), path.join(langTarget, file));
        }
      });
    }

    if (detectedStacks.length > 0) {
      log(`   ğŸ” ê°ì§€ëœ ê¸°ìˆ  ìŠ¤íƒ: ${detectedTypes.join(', ')}\n`);
    }
    log('   âœ… ì½”ë”© ê·œì¹™ ì—…ë°ì´íŠ¸ ì™„ë£Œ (.vibe/rules/)\n');

    // .claude/agents/ ì—…ë°ì´íŠ¸
    const agentsDir = path.join(claudeDir, 'agents');
    ensureDir(agentsDir);
    const agentsSourceDir = path.join(__dirname, '../.claude/agents');
    copyDirContents(agentsSourceDir, agentsDir);
    log('   âœ… ì„œë¸Œì—ì´ì „íŠ¸ ì—…ë°ì´íŠ¸ ì™„ë£Œ (.claude/agents/)\n');

    // settings.jsonì— hooks ë³‘í•© (ì €ì¥ì†Œ ê³µìœ ìš©)
    const settingsPath = path.join(claudeDir, 'settings.json');
    const hooksTemplate = path.join(__dirname, '../templates/hooks-template.json');

    if (fs.existsSync(hooksTemplate)) {
      const vibeHooks = JSON.parse(fs.readFileSync(hooksTemplate, 'utf-8'));

      if (fs.existsSync(settingsPath)) {
        // ê¸°ì¡´ ì„¤ì •ì— hooks ë³‘í•©
        const existingSettings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));

        // í•­ìƒ ìµœì‹  hooksë¡œ ì—…ë°ì´íŠ¸ (ê¸°ì¡´ hooks ë®ì–´ì“°ê¸°)
        existingSettings.hooks = vibeHooks.hooks;
        fs.writeFileSync(settingsPath, JSON.stringify(existingSettings, null, 2));
        log('   âœ… Hooks ì„¤ì • ì—…ë°ì´íŠ¸ ì™„ë£Œ\n');
      } else {
        // ìƒˆë¡œ ìƒì„±
        fs.copyFileSync(hooksTemplate, settingsPath);
        log('   âœ… Hooks ì„¤ì • ìƒì„± ì™„ë£Œ\n');
      }

      // settings.local.jsonì˜ hooksë„ ì—…ë°ì´íŠ¸ (ì´ì „ ë²„ì „ í›… ë®ì–´ì“°ê¸°)
      const settingsLocalPath = path.join(claudeDir, 'settings.local.json');
      if (fs.existsSync(settingsLocalPath)) {
        try {
          const localSettings = JSON.parse(fs.readFileSync(settingsLocalPath, 'utf-8'));

          // ë¡œì»¬ ì„¤ì •ì— hooksê°€ ìˆìœ¼ë©´ ìµœì‹  ë²„ì „ìœ¼ë¡œ ì—…ë°ì´íŠ¸
          if (localSettings.hooks) {
            localSettings.hooks = vibeHooks.hooks;
            fs.writeFileSync(settingsLocalPath, JSON.stringify(localSettings, null, 2));
            log('   âœ… ë¡œì»¬ Hooks ì„¤ì • ì—…ë°ì´íŠ¸ ì™„ë£Œ (settings.local.json)\n');
          }
        } catch (e) {
          // íŒŒì‹± ì—ëŸ¬ ë¬´ì‹œ
        }
      }
    }

    // .gitignoreì—ì„œ settings.local.json ì œê±° (ì €ì¥ì†Œ ê³µìœ  í•„ìš”)
    const gitignorePath = path.join(projectRoot, '.gitignore');
    if (fs.existsSync(gitignorePath)) {
      let gitignore = fs.readFileSync(gitignorePath, 'utf-8');
      if (gitignore.includes('settings.local.json')) {
        gitignore = gitignore.replace(/\.claude\/settings\.local\.json\n?/g, '');
        gitignore = gitignore.replace(/settings\.local\.json\n?/g, '');
        fs.writeFileSync(gitignorePath, gitignore);
        log('   âœ… .gitignoreì—ì„œ settings.local.json ì œê±° (ì €ì¥ì†Œ ê³µìœ )\n');
      }
    }

    // í˜‘ì—…ì ìë™ ì„¤ì¹˜ ì„¤ì • (updateì—ì„œë„ ì‹¤í–‰)
    setupCollaboratorAutoInstall(projectRoot);

    // MCP ì„œë²„: ì „ì—­ vibeì—ì„œ hi-ai/gemini ê²½ë¡œ í™•ì¸ ë° ë“±ë¡
    const vibePath = path.dirname(__dirname);
    const hiAiPath = path.join(vibePath, 'node_modules', '@su-record', 'hi-ai', 'dist', 'index.js');
    const geminiMcpPath = path.join(vibePath, 'lib', 'gemini-mcp.js');

    if (fs.existsSync(hiAiPath)) {
      try {
        const { execSync } = require('child_process');

        // 1. ê¸°ì¡´ ë¡œì»¬ vibe MCP ì œê±° í›„ ì „ì—­ ë“±ë¡
        try {
          execSync(`claude mcp remove vibe`, { stdio: 'pipe' });
        } catch (e) {}
        try {
          execSync(`claude mcp remove vibe -s user`, { stdio: 'pipe' });
        } catch (e) {}
        try {
          execSync(`claude mcp add vibe -s user node "${hiAiPath}"`, { stdio: 'pipe' });
          log('   âœ… vibe MCP ì „ì—­ ë“±ë¡ ì™„ë£Œ (hi-ai)\n');
        } catch (e) {
          if (e.message.includes('already exists')) {
            log('   â„¹ï¸  vibe MCP ì´ë¯¸ ë“±ë¡ë¨\n');
          } else {
            log('   âš ï¸  vibe MCP ë“±ë¡ ì‹¤íŒ¨\n');
          }
        }

        // 2. ê¸°ì¡´ ë¡œì»¬ vibe-gemini MCP ì œê±° í›„ ì „ì—­ ë“±ë¡ (gemini-mcp.js ì¡´ì¬ ì‹œ)
        if (fs.existsSync(geminiMcpPath)) {
          try {
            execSync(`claude mcp remove vibe-gemini`, { stdio: 'pipe' });
          } catch (e) {}
          try {
            execSync(`claude mcp remove vibe-gemini -s user`, { stdio: 'pipe' });
          } catch (e) {}
          try {
            execSync(`claude mcp add vibe-gemini -s user node "${geminiMcpPath}"`, { stdio: 'pipe' });
            log('   âœ… vibe-gemini MCP ì „ì—­ ë“±ë¡ ì™„ë£Œ\n');
          } catch (e) {
            if (e.message.includes('already exists')) {
              log('   â„¹ï¸  vibe-gemini MCP ì´ë¯¸ ë“±ë¡ë¨\n');
            }
          }
        }

        // 3. context7 MCP ì „ì—­ ë“±ë¡ í™•ì¸
        try {
          execSync(`claude mcp remove context7`, { stdio: 'pipe' });
        } catch (e) {}
        try {
          execSync('claude mcp add context7 -s user -- npx -y @upstash/context7-mcp@latest', { stdio: 'pipe' });
          log('   âœ… context7 MCP ì „ì—­ ë“±ë¡ ì™„ë£Œ\n');
        } catch (e) {
          if (e.message.includes('already exists')) {
            log('   â„¹ï¸  context7 MCP ì´ë¯¸ ë“±ë¡ë¨\n');
          }
        }
      } catch (e) {
        log('   âš ï¸  MCP ë“±ë¡ ì‹¤íŒ¨\n');
      }
    }

    // ê¸°ì¡´ .vibe/mcp/ í´ë” ì •ë¦¬ (ë§ˆì´ê·¸ë ˆì´ì…˜)
    const oldMcpDir = path.join(vibeDir, 'mcp');
    if (fs.existsSync(oldMcpDir)) {
      log('   ğŸ§¹ ê¸°ì¡´ .vibe/mcp/ í´ë” ì •ë¦¬ ì¤‘...\n');
      try {
        removeDirRecursive(oldMcpDir);
        log('   âœ… .vibe/mcp/ í´ë” ì‚­ì œ ì™„ë£Œ (ì „ì—­ MCPë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜)\n');
      } catch (e) {
        log('   âš ï¸  .vibe/mcp/ í´ë” ìˆ˜ë™ ì‚­ì œ í•„ìš”\n');
      }
    }

    const packageJson = require('../package.json');
    log(`
âœ… vibe ì—…ë°ì´íŠ¸ ì™„ë£Œ! (v${packageJson.version})

ì—…ë°ì´íŠ¸ëœ í•­ëª©:
  - ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (7ê°œ)
  - ì½”ë”© ê·œì¹™ (.vibe/rules/)
  - ì„œë¸Œì—ì´ì „íŠ¸ (.claude/agents/)
  - Hooks ì„¤ì •

ì™¸ë¶€ LLM (ì„ íƒì ):
  vibe gpt <api-key>      GPT í™œì„±í™” (ì•„í‚¤í…ì²˜/ë””ë²„ê¹…)
  vibe gemini <api-key>   Gemini í™œì„±í™” (UI/UX)
    `);

  } catch (error) {
    console.error('âŒ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error.message);
    process.exit(1);
  }
}

// ì™¸ë¶€ LLM ì„¤ì • (GPT, Gemini)
function setupExternalLLM(llmType, apiKey) {
  if (!apiKey) {
    console.log(`
âŒ API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.

ì‚¬ìš©ë²•:
  vibe ${llmType} <api-key>

${llmType === 'gpt' ? 'OpenAI API í‚¤: https://platform.openai.com/api-keys' : 'Google API í‚¤: https://aistudio.google.com/apikey'}
    `);
    return;
  }

  const projectRoot = process.cwd();
  const vibeDir = path.join(projectRoot, '.vibe');
  const configPath = path.join(vibeDir, 'config.json');

  if (!fs.existsSync(vibeDir)) {
    console.log('âŒ vibe í”„ë¡œì íŠ¸ê°€ ì•„ë‹™ë‹ˆë‹¤. ë¨¼ì € vibe initì„ ì‹¤í–‰í•˜ì„¸ìš”.');
    return;
  }

  // config.json ì—…ë°ì´íŠ¸
  let config = {};
  if (fs.existsSync(configPath)) {
    config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
  }

  if (!config.models) {
    config.models = {};
  }

  const llmConfig = EXTERNAL_LLMS[llmType];
  config.models[llmType] = {
    enabled: true,
    role: llmConfig.role,
    description: llmConfig.description
  };

  fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

  // MCP ì„œë²„ ë“±ë¡ (í™˜ê²½ë³€ìˆ˜ì™€ í•¨ê»˜)
  const { execSync } = require('child_process');
  const envKey = llmConfig.envKey;

  try {
    // ê¸°ì¡´ MCP ì œê±° í›„ ì¬ë“±ë¡
    try {
      execSync(`claude mcp remove ${llmConfig.name} -s user`, { stdio: 'pipe' });
    } catch (e) {
      // ì—†ìœ¼ë©´ ë¬´ì‹œ
    }

    // í™˜ê²½ë³€ìˆ˜ì™€ í•¨ê»˜ MCP ì „ì—­ ë“±ë¡
    execSync(`claude mcp add ${llmConfig.name} -s user -e ${envKey}=${apiKey} -- npx -y ${llmConfig.package}`, { stdio: 'pipe' });

    console.log(`
âœ… ${llmType.toUpperCase()} í™œì„±í™” ì™„ë£Œ! (ì „ì—­)

ì—­í• : ${llmConfig.description}
MCP: ${llmConfig.name}

ëª¨ë“  í”„ë¡œì íŠ¸ì—ì„œ /vibe.run ì‹¤í–‰ ì‹œ ìë™ìœ¼ë¡œ í™œìš©ë©ë‹ˆë‹¤.

ë¹„í™œì„±í™”: vibe ${llmType} --remove
    `);
  } catch (e) {
    console.log(`
âš ï¸  MCP ë“±ë¡ ì‹¤íŒ¨. ìˆ˜ë™ìœ¼ë¡œ ë“±ë¡í•˜ì„¸ìš”:

claude mcp add ${llmConfig.name} -s user -e ${envKey}=<your-key> -- npx -y ${llmConfig.package}
    `);
  }
}

function removeExternalLLM(llmType) {
  const projectRoot = process.cwd();
  const vibeDir = path.join(projectRoot, '.vibe');
  const configPath = path.join(vibeDir, 'config.json');

  if (!fs.existsSync(vibeDir)) {
    console.log('âŒ vibe í”„ë¡œì íŠ¸ê°€ ì•„ë‹™ë‹ˆë‹¤.');
    return;
  }

  // config.json ì—…ë°ì´íŠ¸
  if (fs.existsSync(configPath)) {
    const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    if (config.models && config.models[llmType]) {
      config.models[llmType].enabled = false;
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    }
  }

  // MCP ì„œë²„ ì œê±° (ë¡œì»¬ + ì „ì—­ ëª¨ë‘)
  const { execSync } = require('child_process');
  const llmConfig = EXTERNAL_LLMS[llmType];

  try {
    // ë¡œì»¬ ì œê±°
    try {
      execSync(`claude mcp remove ${llmConfig.name}`, { stdio: 'pipe' });
    } catch (e) {}
    // ì „ì—­ ì œê±°
    try {
      execSync(`claude mcp remove ${llmConfig.name} -s user`, { stdio: 'pipe' });
    } catch (e) {}
    console.log(`âœ… ${llmType.toUpperCase()} ë¹„í™œì„±í™” ì™„ë£Œ`);
  } catch (e) {
    console.log(`â„¹ï¸  ${llmType.toUpperCase()} MCPê°€ ë“±ë¡ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.`);
  }
}

function showStatus() {
  const projectRoot = process.cwd();
  const vibeDir = path.join(projectRoot, '.vibe');
  const configPath = path.join(vibeDir, 'config.json');

  if (!fs.existsSync(vibeDir)) {
    console.log('âŒ vibe í”„ë¡œì íŠ¸ê°€ ì•„ë‹™ë‹ˆë‹¤. ë¨¼ì € vibe initì„ ì‹¤í–‰í•˜ì„¸ìš”.');
    return;
  }

  const packageJson = require('../package.json');
  let config = { language: 'ko', models: {} };
  if (fs.existsSync(configPath)) {
    config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
  }

  const gptStatus = config.models?.gpt?.enabled ? 'âœ… í™œì„±' : 'â¬š ë¹„í™œì„±';
  const geminiStatus = config.models?.gemini?.enabled ? 'âœ… í™œì„±' : 'â¬š ë¹„í™œì„±';

  console.log(`
ğŸ“Š Vibe ìƒíƒœ (v${packageJson.version})

í”„ë¡œì íŠ¸: ${projectRoot}
ì–¸ì–´: ${config.language || 'ko'}

ëª¨ë¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Opus 4.5          ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sonnet 4          êµ¬í˜„                  â”‚
â”‚ Haiku 4.5         ì½”ë“œ íƒìƒ‰             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ GPT 5.2           ${gptStatus}  ì•„í‚¤í…ì²˜/ë””ë²„ê¹…    â”‚
â”‚ Gemini 3          ${geminiStatus}  UI/UX ì„¤ê³„        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

MCP ì„œë²„:
  vibe (hi-ai)      ê¸°ë³¸ ë„êµ¬
  context7          ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ ê²€ìƒ‰

ì™¸ë¶€ LLM ì„¤ì •:
  vibe gpt <key>      GPT í™œì„±í™” (ì•„í‚¤í…ì²˜/ë””ë²„ê¹…)
  vibe gemini <key>   Gemini í™œì„±í™” (UI/UX)
  vibe <name> --remove  ë¹„í™œì„±í™”
  `);
}

// ë²„ì „ ì •ë³´
function showVersion() {
  const packageJson = require('../package.json');
  console.log(`vibe v${packageJson.version}`);
}

// Gemini OAuth ì¸ì¦
async function geminiAuth() {
  console.log(`
ğŸ” Gemini êµ¬ë… ì¸ì¦ (OAuth)

Gemini Advanced êµ¬ë…ì´ ìˆìœ¼ë©´ ì¶”ê°€ ë¹„ìš© ì—†ì´ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë¸Œë¼ìš°ì €ì—ì„œ Google ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì„¸ìš”.
  `);

  try {
    const { startOAuthFlow } = require('../lib/gemini-oauth');
    const storage = require('../lib/gemini-storage');

    const tokens = await startOAuthFlow();

    // ê³„ì • ì €ì¥
    storage.addAccount({
      email: tokens.email,
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expires: tokens.expires,
      projectId: tokens.projectId,
    });

    console.log(`
âœ… Gemini ì¸ì¦ ì™„ë£Œ!

ê³„ì •: ${tokens.email}
í”„ë¡œì íŠ¸: ${tokens.projectId || '(ìë™ ê°ì§€)'}

ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸:
  - Gemini 3 Flash (ë¹ ë¥¸ ì‘ë‹µ, íƒìƒ‰/ê²€ìƒ‰)
  - Gemini 3 Pro (ë†’ì€ ì •í™•ë„)

/vibe.run ì‹¤í–‰ ì‹œ ìë™ìœ¼ë¡œ Geminiê°€ ë³´ì¡° ëª¨ë¸ë¡œ í™œìš©ë©ë‹ˆë‹¤.

ìƒíƒœ í™•ì¸: vibe gemini --status
ë¡œê·¸ì•„ì›ƒ: vibe gemini --logout
    `);

    // config.json ì—…ë°ì´íŠ¸ (gemini oauth í™œì„±í™”)
    const projectRoot = process.cwd();
    const vibeDir = path.join(projectRoot, '.vibe');
    const configPath = path.join(vibeDir, 'config.json');

    if (fs.existsSync(configPath)) {
      try {
        const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
        if (!config.models) config.models = {};
        config.models.gemini = {
          enabled: true,
          authType: 'oauth',
          email: tokens.email,
          role: 'exploration',
          description: 'Gemini 3 Flash/Pro (íƒìƒ‰, UI/UX)',
        };
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
      } catch (e) {}
    }

    // MCP ì„œë²„ ë“±ë¡ (vibe-gemini) - ì „ì—­ ë“±ë¡
    try {
      const vibePath = path.dirname(__dirname);
      const mcpPath = path.join(vibePath, 'lib', 'gemini-mcp.js');

      // ì „ì—­ ë“±ë¡ (-s user)
      execSync('claude mcp remove vibe-gemini -s user 2>/dev/null || true', { stdio: 'ignore' });
      execSync(`claude mcp add vibe-gemini -s user node "${mcpPath}"`, { stdio: 'inherit' });

      console.log(`
âœ… vibe-gemini MCP ì„œë²„ ë“±ë¡ ì™„ë£Œ! (ì „ì—­)

ì´ì œ ëª¨ë“  í”„ë¡œì íŠ¸ì—ì„œ ë‹¤ìŒ ë„êµ¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
  - mcp__vibe-gemini__gemini_chat: Geminiì— ì§ˆë¬¸
  - mcp__vibe-gemini__gemini_analyze_code: ì½”ë“œ ë¶„ì„
  - mcp__vibe-gemini__gemini_review_ui: UI/UX ë¦¬ë·°
  - mcp__vibe-gemini__gemini_quick_ask: ë¹ ë¥¸ ì§ˆë¬¸
      `);
    } catch (mcpError) {
      console.log(`
âš ï¸  MCP ì„œë²„ ë“±ë¡ ì‹¤íŒ¨ (ìˆ˜ë™ ë“±ë¡ í•„ìš”):
  claude mcp add vibe-gemini -s user node "${path.join(path.dirname(__dirname), 'lib', 'gemini-mcp.js')}"
      `);
    }

    // ì¸ì¦ ì™„ë£Œ í›„ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
    process.exit(0);

  } catch (error) {
    console.error(`
âŒ Gemini ì¸ì¦ ì‹¤íŒ¨

ì˜¤ë¥˜: ${error.message}

ë‹¤ì‹œ ì‹œë„í•˜ë ¤ë©´: vibe gemini --auth
    `);
    process.exit(1);
  }
}

// Gemini ì¸ì¦ ìƒíƒœ í™•ì¸
function geminiStatus() {
  try {
    const storage = require('../lib/gemini-storage');
    const { GEMINI_MODELS } = require('../lib/gemini-api');

    const accounts = storage.getAllAccounts();

    if (accounts.length === 0) {
      console.log(`
ğŸ“Š Gemini ì¸ì¦ ìƒíƒœ

ì¸ì¦ëœ ê³„ì • ì—†ìŒ

ë¡œê·¸ì¸: vibe gemini --auth
      `);
      return;
    }

    const activeAccount = storage.getActiveAccount();
    const isExpired = storage.isTokenExpired(activeAccount);

    console.log(`
ğŸ“Š Gemini ì¸ì¦ ìƒíƒœ

í™œì„± ê³„ì •: ${activeAccount.email}
í”„ë¡œì íŠ¸: ${activeAccount.projectId || '(ìë™)'}
í† í° ìƒíƒœ: ${isExpired ? 'âš ï¸  ë§Œë£Œë¨ (ìë™ ê°±ì‹ ë¨)' : 'âœ… ìœ íš¨'}
ë§ˆì§€ë§‰ ì‚¬ìš©: ${new Date(activeAccount.lastUsed).toLocaleString()}

ë“±ë¡ëœ ê³„ì • (${accounts.length}ê°œ):
${accounts.map((acc, i) => `  ${i === storage.loadAccounts()?.activeIndex ? 'â†’' : ' '} ${acc.email}`).join('\n')}

ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸:
${Object.entries(GEMINI_MODELS).map(([id, info]) => `  - ${id}: ${info.description}`).join('\n')}

ë¡œê·¸ì•„ì›ƒ: vibe gemini --logout
    `);

  } catch (error) {
    console.error('ìƒíƒœ í™•ì¸ ì‹¤íŒ¨:', error.message);
  }
}

// Gemini ë¡œê·¸ì•„ì›ƒ
function geminiLogout() {
  try {
    const storage = require('../lib/gemini-storage');
    const activeAccount = storage.getActiveAccount();

    if (!activeAccount) {
      console.log('ë¡œê·¸ì¸ëœ ê³„ì •ì´ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }

    storage.clearAccounts();

    console.log(`
âœ… Gemini ë¡œê·¸ì•„ì›ƒ ì™„ë£Œ

${activeAccount.email} ê³„ì •ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.

ë‹¤ì‹œ ë¡œê·¸ì¸: vibe gemini --auth
    `);

    // config.json ì—…ë°ì´íŠ¸
    const projectRoot = process.cwd();
    const vibeDir = path.join(projectRoot, '.vibe');
    const configPath = path.join(vibeDir, 'config.json');

    if (fs.existsSync(configPath)) {
      try {
        const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
        if (config.models?.gemini) {
          config.models.gemini.enabled = false;
          config.models.gemini.authType = null;
          config.models.gemini.email = null;
          fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
        }
      } catch (e) {}
    }

  } catch (error) {
    console.error('ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨:', error.message);
  }
}

// Gemini ë„ì›€ë§
function showGeminiHelp() {
  console.log(`
ğŸ¤– Gemini ì„¤ì •

Gemini Advanced êµ¬ë…ì´ ìˆìœ¼ë©´ ì¶”ê°€ ë¹„ìš© ì—†ì´ AI ë³´ì¡° ëª¨ë¸ë¡œ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì‚¬ìš© ë°©ë²•:

  1. êµ¬ë… ì¸ì¦ (ê¶Œì¥):
     vibe gemini --auth       Google ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸ (ì¶”ê°€ ë¹„ìš© ì—†ìŒ)

  2. API í‚¤ ë°©ì‹:
     vibe gemini <api-key>    API í‚¤ë¡œ ì„¤ì • (ì‚¬ìš©ëŸ‰ ê³¼ê¸ˆ)

ê´€ë¦¬ ëª…ë ¹ì–´:
  vibe gemini --status      ì¸ì¦ ìƒíƒœ í™•ì¸
  vibe gemini --logout      ë¡œê·¸ì•„ì›ƒ
  vibe gemini --remove      API í‚¤ ì œê±°

ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸:
  - gemini-2.5-flash: ì•ˆì •ì , Thinking ê¸°ëŠ¥ (ê¸°ë³¸)
  - gemini-2.5-flash-lite: ê²½ëŸ‰ ë²„ì „
  - gemini-3-flash: ìµœì‹  í”„ë¦¬ë·°, ë¹ ë¦„
  - gemini-3-pro: ìµœì‹  í”„ë¦¬ë·°, ì •í™•

í™œìš© ë°©ì‹:
  /vibe.run ì‹¤í–‰ ì‹œ ìë™ìœ¼ë¡œ ë‹¤ìŒ ìš©ë„ë¡œ í™œìš©ë©ë‹ˆë‹¤:
  - ì½”ë“œ íƒìƒ‰/ê²€ìƒ‰ (Gemini 3 Flash)
  - UI/UX ë¶„ì„ (Gemini 3 Pro)
  - ë³‘ë ¬ ì‘ì—… ì²˜ë¦¬
  `);
}

// vibe ì œê±°
function remove() {
  const projectRoot = process.cwd();
  const vibeDir = path.join(projectRoot, '.vibe');
  const claudeDir = path.join(projectRoot, '.claude');

  if (!fs.existsSync(vibeDir)) {
    console.log('âŒ vibe í”„ë¡œì íŠ¸ê°€ ì•„ë‹™ë‹ˆë‹¤.');
    return;
  }

  console.log('ğŸ—‘ï¸  vibe ì œê±° ì¤‘...\n');
  const { execSync } = require('child_process');

  // 1. MCP ì„œë²„ ì œê±°
  try {
    execSync('claude mcp remove vibe', { stdio: 'pipe' });
    console.log('   âœ… vibe MCP ì œê±° ì™„ë£Œ\n');
  } catch (e) {
    console.log('   â„¹ï¸  vibe MCP ì´ë¯¸ ì œê±°ë¨ ë˜ëŠ” ì—†ìŒ\n');
  }

  try {
    execSync('claude mcp remove context7', { stdio: 'pipe' });
    console.log('   âœ… context7 MCP ì œê±° ì™„ë£Œ\n');
  } catch (e) {
    console.log('   â„¹ï¸  context7 MCP ì´ë¯¸ ì œê±°ë¨ ë˜ëŠ” ì—†ìŒ\n');
  }

  // 2. .vibe í´ë” ì œê±°
  if (fs.existsSync(vibeDir)) {
    removeDirRecursive(vibeDir);
    console.log('   âœ… .vibe/ í´ë” ì œê±° ì™„ë£Œ\n');
  }

  // 3. .claude/commands ì œê±° (vibe ê´€ë ¨ë§Œ)
  const commandsDir = path.join(claudeDir, 'commands');
  if (fs.existsSync(commandsDir)) {
    const vibeCommands = ['vibe.spec.md', 'vibe.run.md', 'vibe.verify.md', 'vibe.reason.md', 'vibe.analyze.md', 'vibe.ui.md', 'vibe.diagram.md'];
    vibeCommands.forEach(cmd => {
      const cmdPath = path.join(commandsDir, cmd);
      if (fs.existsSync(cmdPath)) {
        fs.unlinkSync(cmdPath);
      }
    });
    console.log('   âœ… ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ì œê±° ì™„ë£Œ\n');
  }

  // 4. .claude/agents ì œê±° (vibe ê´€ë ¨ë§Œ)
  const agentsDir = path.join(claudeDir, 'agents');
  if (fs.existsSync(agentsDir)) {
    const vibeAgents = ['simplifier.md', 'explorer.md', 'implementer.md', 'tester.md', 'searcher.md'];
    vibeAgents.forEach(agent => {
      const agentPath = path.join(agentsDir, agent);
      if (fs.existsSync(agentPath)) {
        fs.unlinkSync(agentPath);
      }
    });
    console.log('   âœ… ì„œë¸Œì—ì´ì „íŠ¸ ì œê±° ì™„ë£Œ\n');
  }

  // 5. .claude/settings.jsonì—ì„œ hooks ì œê±°
  const settingsPath = path.join(claudeDir, 'settings.json');
  if (fs.existsSync(settingsPath)) {
    try {
      const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
      if (settings.hooks) {
        delete settings.hooks;
        fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
        console.log('   âœ… Hooks ì„¤ì • ì œê±° ì™„ë£Œ\n');
      }
    } catch (e) {}
  }

  // 6. hi-ai íŒ¨í‚¤ì§€ëŠ” .vibe/mcp/ì— ì„¤ì¹˜ë˜ì–´ ìˆìœ¼ë¯€ë¡œ
  // .vibe/ í´ë” ì œê±° ì‹œ í•¨ê»˜ ì‚­ì œë¨ (ë³„ë„ ì‘ì—… ë¶ˆí•„ìš”)

  console.log(`
âœ… vibe ì œê±° ì™„ë£Œ!

ì œê±°ëœ í•­ëª©:
  - MCP ì„œë²„ (vibe, context7)
  - .vibe/ í´ë” (hi-ai MCP í¬í•¨)
  - ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ (7ê°œ)
  - ì„œë¸Œì—ì´ì „íŠ¸ (5ê°œ)
  - Hooks ì„¤ì •

ë‹¤ì‹œ ì„¤ì¹˜í•˜ë ¤ë©´: vibe init
  `);
}

// ë©”ì¸ ë¼ìš°í„°
switch (command) {
  case 'init':
    init(positionalArgs[1]); // ì˜µì…˜ ì œì™¸í•œ ì¸ì ì‚¬ìš©
    break;

  case 'update':
    update();
    break;

  case 'remove':
  case 'uninstall':
    remove();
    break;

  case 'gpt':
    if (args[1] === '--remove') {
      removeExternalLLM('gpt');
    } else {
      setupExternalLLM('gpt', args[1]);
    }
    break;

  case 'gemini':
    if (args[1] === '--remove') {
      removeExternalLLM('gemini');
    } else if (args[1] === '--auth') {
      geminiAuth();
    } else if (args[1] === '--status') {
      geminiStatus();
    } else if (args[1] === '--logout') {
      geminiLogout();
    } else if (args[1]) {
      setupExternalLLM('gemini', args[1]);
    } else {
      showGeminiHelp();
    }
    break;

  case 'status':
    showStatus();
    break;

  case 'version':
  case '-v':
  case '--version':
    showVersion();
    break;

  case 'help':
  case '-h':
  case '--help':
  case undefined:
    showHelp();
    break;

  default:
    console.log(`
âŒ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: ${command}

ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´:
  vibe init       í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
  vibe update     ì„¤ì • ì—…ë°ì´íŠ¸
  vibe gpt        GPT í™œì„±í™”/ë¹„í™œì„±í™”
  vibe gemini     Gemini í™œì„±í™”/ë¹„í™œì„±í™”
  vibe status     í˜„ì¬ ì„¤ì • ìƒíƒœ
  vibe help       ë„ì›€ë§
  vibe version    ë²„ì „ ì •ë³´

ì‚¬ìš©ë²•: vibe help
    `);
    process.exit(1);
}
